<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>openjdk8_analysis: java.lang.invoke.MethodHandle Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">openjdk8_analysis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacejava.html">java</a></li><li class="navelem"><a class="el" href="namespacejava_1_1lang.html">lang</a></li><li class="navelem"><a class="el" href="namespacejava_1_1lang_1_1invoke.html">invoke</a></li><li class="navelem"><a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html">MethodHandle</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classjava_1_1lang_1_1invoke_1_1_method_handle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">java.lang.invoke.MethodHandle Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for java.lang.invoke.MethodHandle:</div>
<div class="dyncontent">
<div class="center"><img src="classjava_1_1lang_1_1invoke_1_1_method_handle__inherit__graph.png" border="0" usemap="#java_8lang_8invoke_8_method_handle_inherit__map" alt="Inheritance graph"/></div>
<map name="java_8lang_8invoke_8_method_handle_inherit__map" id="java_8lang_8invoke_8_method_handle_inherit__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for java.lang.invoke.MethodHandle:</div>
<div class="dyncontent">
<div class="center"><img src="classjava_1_1lang_1_1invoke_1_1_method_handle__coll__graph.png" border="0" usemap="#java_8lang_8invoke_8_method_handle_coll__map" alt="Collaboration graph"/></div>
<map name="java_8lang_8invoke_8_method_handle_coll__map" id="java_8lang_8invoke_8_method_handle_coll__map">
<area shape="rect" id="node3" href="classjava_1_1lang_1_1_object.html" title="java.lang.Object" alt="" coords="1205,145,1319,172"/>
<area shape="rect" id="node5" href="interfacejava_1_1lang_1_1reflect_1_1_member.html" title="java.lang.reflect.Member" alt="" coords="456,197,619,224"/>
<area shape="rect" id="node6" href="interfacejava_1_1lang_1_1_cloneable.html" title="java.lang.Cloneable" alt="" coords="471,147,604,173"/>
<area shape="rect" id="node7" href="classjava_1_1lang_1_1_string.html" title="java.lang.String" alt="" coords="482,248,593,275"/>
<area shape="rect" id="node8" href="interfacejava_1_1io_1_1_serializable.html" title="java.io.Serializable" alt="" coords="46,299,175,325"/>
<area shape="rect" id="node14" href="classjava_1_1lang_1_1invoke_1_1_method_type.html" title="java.lang.invoke.MethodType" alt="" coords="444,361,631,388"/>
<area shape="rect" id="node9" href="interfacejava_1_1lang_1_1_comparable.html" title="java.lang.Comparable\l\&lt; String \&gt;" alt="" coords="38,182,183,223"/>
<area shape="rect" id="node10" href="interfacejava_1_1lang_1_1_char_sequence.html" title="java.lang.CharSequence" alt="" coords="30,248,191,275"/>
<area shape="rect" id="node11" href="interfacejava_1_1util_1_1_comparator.html" title="java.util.Comparator\l\&lt; java.lang.String \&gt;" alt="" coords="43,117,179,158"/>
<area shape="rect" id="node16" href="classjava_1_1lang_1_1_class.html" title="java.lang.Class\&lt;?\&gt;" alt="" coords="45,429,177,456"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacejava_1_1lang_1_1invoke_1_1_method_handle_1_1_polymorphic_signature.html">PolymorphicSignature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a931494d72d8da465f6c404122e8f8e24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_type.html">MethodType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#a931494d72d8da465f6c404122e8f8e24">type</a> ()</td></tr>
<tr class="separator:a931494d72d8da465f6c404122e8f8e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21540e7e42ae9b8f1ddabc286b9b57f"><td class="memItemLeft" align="right" valign="top">final native <a class="el" href="classjava_1_1lang_1_1_object.html">Object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f">invokeExact</a> (Object...args)  throws Throwable</td></tr>
<tr class="separator:ab21540e7e42ae9b8f1ddabc286b9b57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7919705abc3fa4810709f3c00d1d47"><td class="memItemLeft" align="right" valign="top">final native <a class="el" href="classjava_1_1lang_1_1_object.html">Object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a> (Object...args)  throws Throwable</td></tr>
<tr class="separator:acd7919705abc3fa4810709f3c00d1d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab605e8b304dffded045540f58bab5dee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classjava_1_1lang_1_1_object.html">Object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab605e8b304dffded045540f58bab5dee">invokeWithArguments</a> (Object...arguments)  throws Throwable </td></tr>
<tr class="separator:ab605e8b304dffded045540f58bab5dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7074b115ecbd049202f2332bdb5e9de2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classjava_1_1lang_1_1_object.html">Object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#a7074b115ecbd049202f2332bdb5e9de2">invokeWithArguments</a> (<a class="el" href="interfacejava_1_1util_1_1_list.html">java.util.List</a>&lt;?&gt; arguments)  throws Throwable </td></tr>
<tr class="separator:a7074b115ecbd049202f2332bdb5e9de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84a7dc38319aca9b668f7c061fbbfe2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html">MethodHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#aa84a7dc38319aca9b668f7c061fbbfe2">asType</a> (<a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_type.html">MethodType</a> newType)</td></tr>
<tr class="separator:aa84a7dc38319aca9b668f7c061fbbfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A method handle is a typed, directly executable reference to an underlying method, constructor, field, or similar low-level operation, with optional transformations of arguments or return values. These transformations are quite general, and include such patterns as  <a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#aa84a7dc38319aca9b668f7c061fbbfe2">asType</a> conversion},  #bindTo insertion},  <a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handles.html#a08cf28c69f75e585094c6ac8179b3b2b">java.lang.invoke.MethodHandles::dropArguments</a> deletion}, and  <a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handles.html#ac1123f9704fae5238f1c0f45ad93da49">java.lang.invoke.MethodHandles::filterArguments</a> substitution}.</p>
<h1>Method handle contents</h1>
<p>Method handles are dynamically and strongly typed according to their parameter and return types. They are not distinguished by the name or the defining class of their underlying methods. A method handle must be invoked using a symbolic type descriptor which matches the method handle's own  #type type descriptor}. </p>
<p>Every method handle reports its type descriptor via the <a class="el" href="">type</a> accessor. This type descriptor is a <a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_type.html">MethodType</a> object, whose structure is a series of classes, one of which is the return type of the method (or</p><div class="fragment"><div class="line"><span class="keywordtype">void</span>.class </div></div><!-- fragment --><p> if none). </p>
<p>A method handle's type controls the types of invocations it accepts, and the kinds of transformations that apply to it. </p>
<p>A method handle contains a pair of special invoker methods called <a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f">invokeExact</a> and <a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a>. Both invoker methods provide direct access to the method handle's underlying method, constructor, field, or other operation, as modified by transformations of arguments and return values. Both invokers accept calls which exactly match the method handle's own type. The plain, inexact invoker also accepts a range of other call types. </p>
<p>Method handles are immutable and have no visible state. Of course, they can be bound to underlying methods or data which exhibit state. With respect to the Java Memory Model, any method handle will behave as if all of its (internal) fields are final variables. This means that any method handle made visible to the application will always be fully formed. This is true even if the method handle is published through a shared variable in a data race. </p>
<p>Method handles cannot be subclassed by the user. Implementations may (or may not) create internal subclasses of</p><div class="fragment"><div class="line">MethodHandle </div></div><!-- fragment --><p> which may be visible via the <a class="el" href="classjava_1_1lang_1_1_object.html#aa584725530d6ec9324c4264da354f3a1">Object.getClass</a> operation. The programmer should not draw conclusions about a method handle from its specific class, as the method handle class hierarchy (if any) may change from time to time or across implementations from different vendors.</p>
<h1>Method handle compilation</h1>
<p>A Java method call expression naming</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f">invokeExact</a> </div></div><!-- fragment --><p> or</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a> </div></div><!-- fragment --><p> can invoke a method handle from Java source code. From the viewpoint of source code, these methods can take any arguments and their result can be cast to any return type. Formally this is accomplished by giving the invoker methods </p><div class="fragment"><div class="line">Object </div></div><!-- fragment --><p> return types and variable arity</p><div class="fragment"><div class="line">Object </div></div><!-- fragment --><p> arguments, but they have an additional quality called <em>signature polymorphism</em> which connects this freedom of invocation directly to the JVM execution stack. </p>
<p>As is usual with virtual methods, source-level calls to</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f">invokeExact</a> </div></div><!-- fragment --><p> and</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a> </div></div><!-- fragment --><p> compile to an</p><div class="fragment"><div class="line">invokevirtual </div></div><!-- fragment --><p> instruction. More unusually, the compiler must record the actual argument types, and may not perform method invocation conversions on the arguments. Instead, it must push them on the stack according to their own unconverted types. The method handle object itself is pushed on the stack before the arguments. The compiler then calls the method handle with a symbolic type descriptor which describes the argument and return types. </p>
<p>To issue a complete symbolic type descriptor, the compiler must also determine the return type. This is based on a cast on the method invocation expression, if there is one, or else</p><div class="fragment"><div class="line">Object </div></div><!-- fragment --><p> if the invocation is an expression or else</p><div class="fragment"><div class="line"><span class="keywordtype">void</span> </div></div><!-- fragment --><p> if the invocation is a statement. The cast may be to a primitive type (but not</p><div class="fragment"><div class="line"><span class="keywordtype">void</span> </div></div><!-- fragment --><p> ). </p>
<p>As a corner case, an uncasted</p><div class="fragment"><div class="line">null </div></div><!-- fragment --><p> argument is given a symbolic type descriptor of</p><div class="fragment"><div class="line"><a class="code" href="namespacejava.html">java</a>.<a class="code" href="namespacejava_1_1lang.html">lang</a>.<a class="code" href="classjava_1_1lang_1_1_void.html">Void</a> </div></div><!-- fragment --><p> . The ambiguity with the type</p><div class="fragment"><div class="line">Void </div></div><!-- fragment --><p> is harmless, since there are no references of type </p><div class="fragment"><div class="line">Void </div></div><!-- fragment --><p> except the null reference.</p>
<h1>Method handle invocation</h1>
<p>The first time a</p><div class="fragment"><div class="line">invokevirtual </div></div><!-- fragment --><p> instruction is executed it is linked, by symbolically resolving the names in the instruction and verifying that the method call is statically legal. This is true of calls to</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f">invokeExact</a> </div></div><!-- fragment --><p> and</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a> </div></div><!-- fragment --><p> . In this case, the symbolic type descriptor emitted by the compiler is checked for correct syntax and names it contains are resolved. Thus, an</p><div class="fragment"><div class="line">invokevirtual </div></div><!-- fragment --><p> instruction which invokes a method handle will always link, as long as the symbolic type descriptor is syntactically well-formed and the types exist. </p>
<p>When the</p><div class="fragment"><div class="line">invokevirtual </div></div><!-- fragment --><p> is executed after linking, the receiving method handle's type is first checked by the JVM to ensure that it matches the symbolic type descriptor. If the type match fails, it means that the method which the caller is invoking is not present on the individual method handle being invoked. </p>
<p>In the case of</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f">invokeExact</a> </div></div><!-- fragment --><p> , the type descriptor of the invocation (after resolving symbolic type names) must exactly match the method type of the receiving method handle. In the case of plain, inexact</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a> </div></div><!-- fragment --><p> , the resolved type descriptor must be a valid argument to the receiver's <a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#aa84a7dc38319aca9b668f7c061fbbfe2">asType</a> method. Thus, plain</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a> </div></div><!-- fragment --><p> is more permissive than</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f">invokeExact</a> </div></div><!-- fragment --><p> . </p>
<p>After type matching, a call to</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f">invokeExact</a> </div></div><!-- fragment --><p> directly and immediately invoke the method handle's underlying method (or other behavior, as the case may be). </p>
<p>A call to plain</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a> </div></div><!-- fragment --><p> works the same as a call to </p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f">invokeExact</a> </div></div><!-- fragment --><p> , if the symbolic type descriptor specified by the caller exactly matches the method handle's own type. If there is a type mismatch,</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a> </div></div><!-- fragment --><p> attempts to adjust the type of the receiving method handle, as if by a call to <a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#aa84a7dc38319aca9b668f7c061fbbfe2">asType</a>, to obtain an exactly invokable method handle</p><div class="fragment"><div class="line">M2 </div></div><!-- fragment --><p> . This allows a more powerful negotiation of method type between caller and callee. </p>
<p>(<em>Note:</em> The adjusted method handle</p><div class="fragment"><div class="line">M2 </div></div><!-- fragment --><p> is not directly observable, and implementations are therefore not required to materialize it.)</p>
<h1>Invocation checking</h1>
<p>In typical programs, method handle type matching will usually succeed. But if a match fails, the JVM will throw a <a class="el" href="classjava_1_1lang_1_1invoke_1_1_wrong_method_type_exception.html">WrongMethodTypeException</a>, either directly (in the case of</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f">invokeExact</a> </div></div><!-- fragment --><p> ) or indirectly as if by a failed call to</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#aa84a7dc38319aca9b668f7c061fbbfe2">asType</a> </div></div><!-- fragment --><p> (in the case of</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a> </div></div><!-- fragment --><p> ). </p>
<p>Thus, a method type mismatch which might show up as a linkage error in a statically typed program can show up as a dynamic</p><div class="fragment"><div class="line">WrongMethodTypeException </div></div><!-- fragment --><p> in a program which uses method handles. </p>
<p>Because method types contain "live"</p><div class="fragment"><div class="line">Class </div></div><!-- fragment --><p> objects, method type matching takes into account both types names and class loaders. Thus, even if a method handle</p><div class="fragment"><div class="line">M </div></div><!-- fragment --><p> is created in one class loader</p><div class="fragment"><div class="line">L1 </div></div><!-- fragment --><p> and used in another</p><div class="fragment"><div class="line">L2 </div></div><!-- fragment --><p> , method handle calls are type-safe, because the caller's symbolic type descriptor, as resolved in</p><div class="fragment"><div class="line">L2 </div></div><!-- fragment --><p> , is matched against the original callee method's symbolic type descriptor, as resolved in</p><div class="fragment"><div class="line">L1 </div></div><!-- fragment --><p> . The resolution in</p><div class="fragment"><div class="line">L1 </div></div><!-- fragment --><p> happens when</p><div class="fragment"><div class="line">M </div></div><!-- fragment --><p> is created and its type is assigned, while the resolution in</p><div class="fragment"><div class="line">L2 </div></div><!-- fragment --><p> happens when the</p><div class="fragment"><div class="line">invokevirtual </div></div><!-- fragment --><p> instruction is linked. </p>
<p>Apart from the checking of type descriptors, a method handle's capability to call its underlying method is unrestricted. If a method handle is formed on a non-public method by a class that has access to that method, the resulting handle can be used in any place by any caller who receives a reference to it. </p>
<p>Unlike with the Core Reflection API, where access is checked every time a reflective method is invoked, method handle access checking is performed <a href="MethodHandles.Lookup.html#access">when the method handle is created</a>. In the case of</p><div class="fragment"><div class="line">ldc </div></div><!-- fragment --><p> (see below), access checking is performed as part of linking the constant pool entry underlying the constant method handle. </p>
<p>Thus, handles to non-public methods, or to methods in non-public classes, should generally be kept secret. They should not be passed to untrusted code unless their use from the untrusted code would be harmless.</p>
<h1>Method handle creation</h1>
<p>Java code can create a method handle that directly accesses any method, constructor, or field that is accessible to that code. This is done via a reflective, capability-based API called <a class="el" href="">MethodHandles.Lookup</a> For example, a static method handle can be obtained from <a class="el" href="">Lookup.findStatic</a>. There are also conversion methods from Core Reflection API objects, such as <a class="el" href="">Lookup.unreflect</a>. </p>
<p>Like classes and strings, method handles that correspond to accessible fields, methods, and constructors can also be represented directly in a class file's constant pool as constants to be loaded by</p><div class="fragment"><div class="line">ldc </div></div><!-- fragment --><p> bytecodes. A new type of constant pool entry,</p><div class="fragment"><div class="line">CONSTANT_MethodHandle </div></div><!-- fragment --><p> , refers directly to an associated</p><div class="fragment"><div class="line">CONSTANT_Methodref </div></div><!-- fragment --><p> , </p><div class="fragment"><div class="line">CONSTANT_InterfaceMethodref </div></div><!-- fragment --><p> , or</p><div class="fragment"><div class="line">CONSTANT_Fieldref </div></div><!-- fragment --><p> constant pool entry. (For full details on method handle constants, see sections 4.4.8 and 5.4.3.5 of the Java Virtual Machine Specification.) </p>
<p>Method handles produced by lookups or constant loads from methods or constructors with the variable arity modifier bit (</p><div class="fragment"><div class="line">0x0080 </div></div><!-- fragment --><p> ) have a corresponding variable arity, as if they were defined with the help of <a class="el" href="">asVarargsCollector</a>. </p>
<p>A method reference may refer either to a static or non-static method. In the non-static case, the method handle type includes an explicit receiver argument, prepended before any other arguments. In the method handle's type, the initial receiver argument is typed according to the class under which the method was initially requested. (E.g., if a non-static method handle is obtained via</p><div class="fragment"><div class="line">ldc </div></div><!-- fragment --><p> , the type of the receiver is the class named in the constant pool entry.) </p>
<p>Method handle constants are subject to the same link-time access checks their corresponding bytecode instructions, and the</p><div class="fragment"><div class="line">ldc </div></div><!-- fragment --><p> instruction will throw corresponding linkage errors if the bytecode behaviors would throw such errors. </p>
<p>As a corollary of this, access to protected members is restricted to receivers only of the accessing class, or one of its subclasses, and the accessing class must in turn be a subclass (or package sibling) of the protected member's defining class. If a method reference refers to a protected non-static method or field of a class outside the current package, the receiver argument will be narrowed to the type of the accessing class. </p>
<p>When a method handle to a virtual method is invoked, the method is always looked up in the receiver (that is, the first argument). </p>
<p>A non-virtual method handle to a specific virtual method implementation can also be created. These do not perform virtual lookup based on receiver type. Such a method handle simulates the effect of an</p><div class="fragment"><div class="line">invokespecial </div></div><!-- fragment --><p> instruction to the same method.</p>
<h1>Usage examples</h1>
<p>Here are some examples of usage: </p><blockquote class="doxtable">
<pre><div class="fragment"><div class="line">Object x, y; String s; <span class="keywordtype">int</span> i;</div><div class="line">MethodType mt; MethodHandle mh;</div><div class="line">MethodHandles.Lookup lookup = MethodHandles.lookup();</div><div class="line"><span class="comment">// mt is (char,char)String</span></div><div class="line">mt = MethodType.methodType(String.class, <span class="keywordtype">char</span>.class, <span class="keywordtype">char</span>.class);</div><div class="line">mh = lookup.findVirtual(String.class, <span class="stringliteral">&quot;replace&quot;</span>, mt);</div><div class="line">s = (String) mh.invokeExact(<span class="stringliteral">&quot;daddy&quot;</span>,<span class="charliteral">&#39;d&#39;</span>,<span class="charliteral">&#39;n&#39;</span>);</div><div class="line"><span class="comment">// invokeExact(Ljava/lang/String;CC)Ljava/lang/String;</span></div><div class="line">assertEquals(s, <span class="stringliteral">&quot;nanny&quot;</span>);</div><div class="line"><span class="comment">// weakly typed invocation (using MHs.invoke)</span></div><div class="line">s = (String) mh.invokeWithArguments(<span class="stringliteral">&quot;sappy&quot;</span>, <span class="charliteral">&#39;p&#39;</span>, <span class="charliteral">&#39;v&#39;</span>);</div><div class="line">assertEquals(s, <span class="stringliteral">&quot;savvy&quot;</span>);</div><div class="line"><span class="comment">// mt is (Object[])List</span></div><div class="line">mt = MethodType.methodType(<a class="code" href="namespacejava.html">java</a>.<a class="code" href="namespacejava_1_1util.html">util</a>.<a class="code" href="interfacejava_1_1util_1_1_list.html">List</a>.class, Object[].class);</div><div class="line">mh = lookup.findStatic(<a class="code" href="namespacejava.html">java</a>.<a class="code" href="namespacejava_1_1util.html">util</a>.<a class="code" href="classjava_1_1util_1_1_arrays.html">Arrays</a>.class, <span class="stringliteral">&quot;asList&quot;</span>, mt);</div><div class="line">assert(mh.isVarargsCollector());</div><div class="line">x = mh.invoke(<span class="stringliteral">&quot;one&quot;</span>, <span class="stringliteral">&quot;two&quot;</span>);</div><div class="line"><span class="comment">// invoke(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;</span></div><div class="line">assertEquals(x, <a class="code" href="namespacejava.html">java</a>.<a class="code" href="namespacejava_1_1util.html">util</a>.<a class="code" href="classjava_1_1util_1_1_arrays.html">Arrays</a>.<a class="code" href="classjava_1_1util_1_1_arrays.html#a9136318d6e833ddd37d71718ed86a1a4">asList</a>(<span class="stringliteral">&quot;one&quot;</span>,<span class="stringliteral">&quot;two&quot;</span>));</div><div class="line"><span class="comment">// mt is (Object,Object,Object)Object</span></div><div class="line">mt = MethodType.genericMethodType(3);</div><div class="line">mh = mh.asType(mt);</div><div class="line">x = mh.invokeExact((Object)1, (Object)2, (Object)3);</div><div class="line"><span class="comment">// invokeExact(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;</span></div><div class="line">assertEquals(x, <a class="code" href="namespacejava.html">java</a>.<a class="code" href="namespacejava_1_1util.html">util</a>.<a class="code" href="classjava_1_1util_1_1_arrays.html">Arrays</a>.<a class="code" href="classjava_1_1util_1_1_arrays.html#a9136318d6e833ddd37d71718ed86a1a4">asList</a>(1,2,3));</div><div class="line"><span class="comment">// mt is ()int</span></div><div class="line">mt = MethodType.methodType(<span class="keywordtype">int</span>.<span class="keyword">class</span>);</div><div class="line">mh = lookup.findVirtual(<a class="code" href="namespacejava.html">java</a>.<a class="code" href="namespacejava_1_1util.html">util</a>.<a class="code" href="interfacejava_1_1util_1_1_list.html">List</a>.class, <span class="stringliteral">&quot;size&quot;</span>, mt);</div><div class="line">i = (int) mh.invokeExact(<a class="code" href="namespacejava.html">java</a>.<a class="code" href="namespacejava_1_1util.html">util</a>.<a class="code" href="classjava_1_1util_1_1_arrays.html">Arrays</a>.<a class="code" href="classjava_1_1util_1_1_arrays.html#a9136318d6e833ddd37d71718ed86a1a4">asList</a>(1,2,3));</div><div class="line"><span class="comment">// invokeExact(Ljava/util/List;)I</span></div><div class="line">assert(i == 3);</div><div class="line">mt = MethodType.methodType(<span class="keywordtype">void</span>.<span class="keyword">class</span>, String.class);</div><div class="line">mh = lookup.findVirtual(<a class="code" href="namespacejava.html">java</a>.<a class="code" href="namespacejava_1_1io.html">io</a>.<a class="code" href="classjava_1_1io_1_1_print_stream.html">PrintStream</a>.class, <span class="stringliteral">&quot;println&quot;</span>, mt);</div><div class="line">mh.invokeExact(System.out, <span class="stringliteral">&quot;Hello, world.&quot;</span>);</div><div class="line"><span class="comment">// invokeExact(Ljava/io/PrintStream;Ljava/lang/String;)V</span></div></div><!-- fragment --> </pre></blockquote>
<p>Each of the above calls to</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f">invokeExact</a> </div></div><!-- fragment --><p> or plain</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a> </div></div><!-- fragment --><p> generates a single invokevirtual instruction with the symbolic type descriptor indicated in the following comment. In these examples, the helper method</p><div class="fragment"><div class="line">assertEquals </div></div><!-- fragment --><p> is assumed to be a method which calls <a class="el" href="classjava_1_1util_1_1_objects.html#acdf9cd7be168684e357fbdb1e6f0421d">Objects.equals</a> on its arguments, and asserts that the result is true.</p>
<h1>Exceptions</h1>
<p>The methods</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f">invokeExact</a> </div></div><!-- fragment --><p> and</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a> </div></div><!-- fragment --><p> are declared to throw <a class="el" href="classjava_1_1lang_1_1_throwable.html">Throwable</a>, which is to say that there is no static restriction on what a method handle can throw. Since the JVM does not distinguish between checked and unchecked exceptions (other than by their class, of course), there is no particular effect on bytecode shape from ascribing checked exceptions to method handle invocations. But in Java source code, methods which perform method handle calls must either explicitly throw</p><div class="fragment"><div class="line">Throwable </div></div><!-- fragment --><p> , or else must catch all throwables locally, rethrowing only those which are legal in the context, and wrapping ones which are illegal.</p>
<h1><a class="anchor" id="sigpoly"></a>Signature polymorphism</h1>
<p>The unusual compilation and linkage behavior of </p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f">invokeExact</a> </div></div><!-- fragment --><p> and plain</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a> </div></div><!-- fragment --><p> is referenced by the term <em>signature polymorphism</em>. As defined in the Java Language Specification, a signature polymorphic method is one which can operate with any of a wide range of call signatures and return types. </p>
<p>In source code, a call to a signature polymorphic method will compile, regardless of the requested symbolic type descriptor. As usual, the Java compiler emits an</p><div class="fragment"><div class="line">invokevirtual </div></div><!-- fragment --><p> instruction with the given symbolic type descriptor against the named method. The unusual part is that the symbolic type descriptor is derived from the actual argument and return types, not from the method declaration. </p>
<p>When the JVM processes bytecode containing signature polymorphic calls, it will successfully link any such call, regardless of its symbolic type descriptor. (In order to retain type safety, the JVM will guard such calls with suitable dynamic type checks, as described elsewhere.) </p>
<p>Bytecode generators, including the compiler back end, are required to emit untransformed symbolic type descriptors for these methods. Tools which determine symbolic linkage are required to accept such untransformed descriptors, without reporting linkage errors.</p>
<h1>Interoperation between method handles and the Core Reflection API</h1>
<p>Using factory methods in the <a class="el" href="">Lookup</a> API, any class member represented by a Core Reflection API object can be converted to a behaviorally equivalent method handle. For example, a reflective <a class="el" href="classjava_1_1lang_1_1reflect_1_1_method.html">Method</a> can be converted to a method handle using <a class="el" href="">Lookup.unreflect</a>. The resulting method handles generally provide more direct and efficient access to the underlying class members. </p>
<p>As a special case, when the Core Reflection API is used to view the signature polymorphic methods</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f">invokeExact</a> </div></div><!-- fragment --><p> or plain</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a> </div></div><!-- fragment --><p> in this class, they appear as ordinary non-polymorphic methods. Their reflective appearance, as viewed by <a class="el" href="classjava_1_1lang_1_1_class.html#a859ab8e7a12c55a2486bd6a0fe323b2b">Class.getDeclaredMethod</a>, is unaffected by their special status in this API. For example, <a class="el" href="classjava_1_1lang_1_1reflect_1_1_method.html#a88f82d7583788e8440026b85185ca632">Method.getModifiers</a> will report exactly those modifier bits required for any similarly declared method, including in this case</p><div class="fragment"><div class="line">native </div></div><!-- fragment --><p> and</p><div class="fragment"><div class="line">varargs </div></div><!-- fragment --><p> bits. </p>
<p>As with any reflected method, these methods (when reflected) may be invoked via <a class="el" href="classjava_1_1lang_1_1reflect_1_1_method.html#a8365954a258a062e9a5a87a78e624fbd">java.lang.reflect.Method.invoke</a>. However, such reflective calls do not result in method handle invocations. Such a call, if passed the required argument (a single one, of type</p><div class="fragment"><div class="line">Object[] </div></div><!-- fragment --><p> ), will ignore the argument and will throw an</p><div class="fragment"><div class="line">UnsupportedOperationException </div></div><!-- fragment --><p> . </p>
<p>Since</p><div class="fragment"><div class="line">invokevirtual </div></div><!-- fragment --><p> instructions can natively invoke method handles under any symbolic type descriptor, this reflective view conflicts with the normal presentation of these methods via bytecodes. Thus, these two native methods, when reflectively viewed by </p><div class="fragment"><div class="line">Class.getDeclaredMethod </div></div><!-- fragment --><p> , may be regarded as placeholders only. </p>
<p>In order to obtain an invoker method for a particular type descriptor, use <a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handles.html#a25370fc9c8679f33259bf92f938118f1">MethodHandles.exactInvoker</a>, or <a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handles.html#a83c2da9160878bc1295f18841221152d">MethodHandles.invoker</a>. The <a class="el" href="">Lookup.findVirtual</a> API is also able to return a method handle to call</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f">invokeExact</a> </div></div><!-- fragment --><p> or plain</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a> </div></div><!-- fragment --><p> , for any specified type descriptor .</p>
<h1>Interoperation between method handles and Java generics</h1>
<p>A method handle can be obtained on a method, constructor, or field which is declared with Java generic types. As with the Core Reflection API, the type of the method handle will constructed from the erasure of the source-level type. When a method handle is invoked, the types of its arguments or the return value cast type may be generic types or type instances. If this occurs, the compiler will replace those types by their erasures when it constructs the symbolic type descriptor for the</p><div class="fragment"><div class="line">invokevirtual </div></div><!-- fragment --><p> instruction. </p>
<p>Method handles do not represent their function-like types in terms of Java parameterized (generic) types, because there are three mismatches between function-like types and parameterized Java types. </p><ul>
<li>
Method types range over all possible arities, from no arguments to up to the <a href="MethodHandle.html#maxarity">maximum number</a> of allowed arguments. Generics are not variadic, and so cannot represent this. </li>
<li>
Method types can specify arguments of primitive types, which Java generic types cannot range over. </li>
<li>
Higher order functions over method handles (combinators) are often generic across a wide range of function types, including those of multiple arities. It is impossible to represent such genericity with a Java type parameter. </li>
</ul>
<h1><a class="anchor" id="maxarity"></a>Arity limits</h1>
<p>The JVM imposes on all methods and constructors of any kind an absolute limit of 255 stacked arguments. This limit can appear more restrictive in certain cases: </p><ul>
<li>
A<div class="fragment"><div class="line"><span class="keywordtype">long</span> </div></div><!-- fragment --> or<div class="fragment"><div class="line"><span class="keywordtype">double</span> </div></div><!-- fragment --> argument counts (for purposes of arity limits) as two argument slots. </li>
<li>
A non-static method consumes an extra argument for the object on which the method is called. </li>
<li>
A constructor consumes an extra argument for the object which is being constructed. </li>
<li>
Since a method handle&rsquo;s<div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a> </div></div><!-- fragment --> method (or other signature-polymorphic method) is non-virtual, it consumes an extra argument for the method handle itself, in addition to any non-virtual receiver object. </li>
</ul>
<p>These limits imply that certain method handles cannot be created, solely because of the JVM limit on stacked arguments. For example, if a static JVM method accepts exactly 255 arguments, a method handle cannot be created for it. Attempts to create method handles with impossible method types lead to an <a class="el" href="">IllegalArgumentException</a>. In particular, a method handle&rsquo;s type must not have an arity of the exact maximum 255.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_type.html">MethodType</a> </dd>
<dd>
<a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handles.html">MethodHandles</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>John Rose, JSR 292 EG </dd></dl>

<p>Definition at line <a class="el" href="_method_handle_8java_source.html#l00421">421</a> of file <a class="el" href="_method_handle_8java_source.html">MethodHandle.java</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa84a7dc38319aca9b668f7c061fbbfe2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html">MethodHandle</a> java.lang.invoke.MethodHandle.asType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_type.html">MethodType</a>&#160;</td>
          <td class="paramname"><em>newType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produces an adapter method handle which adapts the type of the current method handle to a new type. The resulting method handle is guaranteed to report a type which is equal to the desired new type. </p>
<p>If the original type and new type are equal, returns</p><div class="fragment"><div class="line"><span class="keyword">this</span> </div></div><!-- fragment --><p> . </p>
<p>The new method handle, when invoked, will perform the following steps: </p><ul>
<li>
Convert the incoming argument list to match the original method handle's argument list. </li>
<li>
Invoke the original method handle on the converted argument list. </li>
<li>
Convert any result returned by the original method handle to the return type of new method handle. </li>
</ul>
<p>This method provides the crucial behavioral difference between <a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f">invokeExact</a> and plain, inexact <a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a>. The two methods perform the same steps when the caller's type descriptor exactly m atches the callee's, but when the types differ, plain <a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a> also calls</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#aa84a7dc38319aca9b668f7c061fbbfe2">asType</a> </div></div><!-- fragment --><p> (or some internal equivalent) in order to match up the caller's and callee's types. </p>
<p>If the current method is a variable arity method handle argument list conversion may involve the conversion and collection of several arguments into an array, as  #asVarargsCollector described elsewhere}. In every other case, all conversions are applied <em>pairwise</em>, which means that each argument or return value is converted to exactly one argument or return value (or no return value). The applied conversions are defined by consulting the the corresponding component types of the old and new method handle types. </p>
<p>Let <em>T0</em> and <em>T1</em> be corresponding new and old parameter types, or old and new return types. Specifically, for some valid index</p><div class="fragment"><div class="line">i </div></div><!-- fragment --><p> , let <em>T0</em></p><div class="fragment"><div class="line">=newType.parameterType(i) </div></div><!-- fragment --><p> and <em>T1</em></p><div class="fragment"><div class="line">=this.<a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#a931494d72d8da465f6c404122e8f8e24">type</a>().<a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_type.html#a19325cac1d745ea178301372ae91b60f">parameterType</a>(i) </div></div><!-- fragment --><p> . Or else, going the other way for return values, let <em>T0</em></p><div class="fragment"><div class="line">=this.<a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#a931494d72d8da465f6c404122e8f8e24">type</a>().<a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_type.html#a428ecac25f63ce4cb41ef38945df6869">returnType</a>() </div></div><!-- fragment --><p> and <em>T1</em></p><div class="fragment"><div class="line">=newType.returnType() </div></div><!-- fragment --><p> . If the types are the same, the new method handle makes no change to the corresponding argument or return value (if any). Otherwise, one of the following conversions is applied if possible: </p><ul>
<li>
If <em>T0</em> and <em>T1</em> are references, then a cast to <em>T1</em> is applied. (The types do not need to be related in any particular way. This is because a dynamic value of null can convert to any reference type.) </li>
<li>
If <em>T0</em> and <em>T1</em> are primitives, then a Java method invocation conversion (JLS 5.3) is applied, if one exists. (Specifically, <em>T0</em> must convert to <em>T1</em> by a widening primitive conversion.) </li>
<li>
If <em>T0</em> is a primitive and <em>T1</em> a reference, a Java casting conversion (JLS 5.5) is applied if one exists. (Specifically, the value is boxed from <em>T0</em> to its wrapper class, which is then widened as needed to <em>T1</em>.) </li>
<li>
If <em>T0</em> is a reference and <em>T1</em> a primitive, an unboxing conversion will be applied at runtime, possibly followed by a Java method invocation conversion (JLS 5.3) on the primitive value. (These are the primitive widening conversions.) <em>T0</em> must be a wrapper class or a supertype of one. (In the case where <em>T0</em> is <a class="el" href="classjava_1_1lang_1_1_object.html">Object</a>, these are the conversions allowed by <a class="el" href="classjava_1_1lang_1_1reflect_1_1_method.html#a8365954a258a062e9a5a87a78e624fbd">java.lang.reflect.Method.invoke</a>.) The unboxing conversion must have a possibility of success, which means that if <em>T0</em> is not itself a wrapper class, there must exist at least one wrapper class <em>TW</em> which is a subtype of <em>T0</em> and whose unboxed primitive value can be widened to <em>T1</em>. </li>
<li>
If the return type <em>T1</em> is marked as void, any returned value is discarded </li>
<li>
If the return type <em>T0</em> is void and <em>T1</em> a reference, a null value is introduced. </li>
<li>
If the return type <em>T0</em> is void and <em>T1</em> a primitive, a zero value is introduced. </li>
</ul>
<p>(<em>Note:</em> Both <em>T0</em> and <em>T1</em> may be regarded as static types, because neither corresponds specifically to the <em>dynamic type</em> of any actual argument or return value.) </p>
<p>The method handle conversion cannot be made if any one of the required pairwise conversions cannot be made. </p>
<p>At runtime, the conversions applied to reference arguments or return values may require additional runtime checks which can fail. An unboxing operation may fail because the original reference is null, causing a <a class="el" href="classjava_1_1lang_1_1_null_pointer_exception.html">NullPointerException</a>. An unboxing operation or a reference cast may also fail on a reference to an object of the wrong type, causing a <a class="el" href="classjava_1_1lang_1_1_class_cast_exception.html">ClassCastException</a>. Although an unboxing operation may accept several kinds of wrappers, if none are available, a</p><div class="fragment"><div class="line">ClassCastException </div></div><!-- fragment --><p> will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newType</td><td>the expected type of the new method handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a method handle which delegates to<div class="fragment"><div class="line"><span class="keyword">this</span> </div></div><!-- fragment --> after performing any necessary argument conversions, and arranges for any necessary return value conversions </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjava_1_1lang_1_1_null_pointer_exception.html">NullPointerException</a></td><td>if<div class="fragment"><div class="line">newType </div></div><!-- fragment --> is a null reference </td></tr>
    <tr><td class="paramname"><a class="el" href="classjava_1_1lang_1_1invoke_1_1_wrong_method_type_exception.html">WrongMethodTypeException</a></td><td>if the conversion cannot be made </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handles.html#aa00c85f7eacf97f8205313b7986b93eb" title="method handle modification (creation from other method handles) ">MethodHandles::explicitCastArguments</a> </dd></dl>

<p>Definition at line <a class="el" href="_method_handle_8java_source.html#l00750">750</a> of file <a class="el" href="_method_handle_8java_source.html">MethodHandle.java</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classjava_1_1lang_1_1invoke_1_1_method_handle_aa84a7dc38319aca9b668f7c061fbbfe2_cgraph.png" border="0" usemap="#classjava_1_1lang_1_1invoke_1_1_method_handle_aa84a7dc38319aca9b668f7c061fbbfe2_cgraph" alt=""/></div>
<map name="classjava_1_1lang_1_1invoke_1_1_method_handle_aa84a7dc38319aca9b668f7c061fbbfe2_cgraph" id="classjava_1_1lang_1_1invoke_1_1_method_handle_aa84a7dc38319aca9b668f7c061fbbfe2_cgraph">
<area shape="rect" id="node2" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#a931494d72d8da465f6c404122e8f8e24" title="java.lang.invoke.MethodHandle.type" alt="" coords="323,42,551,69"/>
<area shape="rect" id="node5" href="classjava_1_1lang_1_1invoke_1_1_method_type.html#a4e4a2194102ad41edce4aa73073e8e7a" title="java.lang.invoke.MethodType.parameter\lCount" alt="" coords="313,93,562,135"/>
<area shape="rect" id="node6" href="classjava_1_1lang_1_1_class.html#a25ae60d66224653d22caa7cca2bfcc77" title="java.lang.Class.getComponentType" alt="" coords="325,159,550,186"/>
<area shape="rect" id="node7" href="classjava_1_1lang_1_1invoke_1_1_method_type.html#a19325cac1d745ea178301372ae91b60f" title="java.lang.invoke.MethodType.parameterType" alt="" coords="299,210,576,237"/>
<area shape="rect" id="node8" href="classjava_1_1lang_1_1_class.html#a8c180812f0af628c1aff60f6615f59b4" title="java.lang.Class.isAssignableFrom" alt="" coords="329,261,546,287"/>
<area shape="rect" id="node9" href="classjava_1_1lang_1_1_class.html#a12ec9e253bb0bc749fa0b62061b01009" title="java.lang.Class.isArray" alt="" coords="360,311,515,338"/>
<area shape="rect" id="node10" href="classjava_1_1util_1_1_arrays.html#a9136318d6e833ddd37d71718ed86a1a4" title="java.util.Arrays.asList" alt="" coords="364,362,511,389"/>
<area shape="rect" id="node3" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f" title="java.lang.invoke.MethodHandle.invoke\lExact" alt="" coords="624,5,863,47"/>
<area shape="rect" id="node4" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47" title="java.lang.invoke.MethodHandle.invoke" alt="" coords="624,71,863,98"/>
<area shape="rect" id="node11" href="classjava_1_1util_1_1_objects.html#a6b43262fcf49f4c1c7f4b07f4df020f8" title="java.util.Objects.require\lNonNull" alt="" coords="1155,279,1312,320"/>
<area shape="rect" id="node12" href="classjava_1_1util_1_1_arrays.html#a529c2ea0da9e1636215502e962abb3a3" title="java.util.Arrays.copyOf" alt="" coords="667,286,819,313"/>
<area shape="rect" id="node13" href="classjava_1_1util_1_1_arrays.html#a70a18d412ed36c0b60fda282798ef22e" title="java.util.Arrays.spliterator" alt="" coords="659,337,827,363"/>
<area shape="rect" id="node14" href="classjava_1_1util_1_1_spliterators.html#a551f8ee1706f98e800902ab580200b7e" title="java.util.Spliterators.spliterator" alt="" coords="911,337,1107,363"/>
<area shape="rect" id="node15" href="interfacejava_1_1util_1_1function_1_1_consumer.html#a7a43b96adbff93ff90652a2816a078a6" title="java.util.function.Consumer.accept" alt="" coords="633,438,853,465"/>
<area shape="rect" id="node16" href="classjava_1_1util_1_1_arrays.html#ae123430dd440126aa99d6bc7a294afe4" title="java.util.Arrays.sort" alt="" coords="677,489,810,515"/>
</map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classjava_1_1lang_1_1invoke_1_1_method_handle_aa84a7dc38319aca9b668f7c061fbbfe2_icgraph.png" border="0" usemap="#classjava_1_1lang_1_1invoke_1_1_method_handle_aa84a7dc38319aca9b668f7c061fbbfe2_icgraph" alt=""/></div>
<map name="classjava_1_1lang_1_1invoke_1_1_method_handle_aa84a7dc38319aca9b668f7c061fbbfe2_icgraph" id="classjava_1_1lang_1_1invoke_1_1_method_handle_aa84a7dc38319aca9b668f7c061fbbfe2_icgraph">
<area shape="rect" id="node2" href="classjava_1_1lang_1_1invoke_1_1_call_site.html#ac8d05a69dfddad40bbb02ea1abd0ea3e" title="java.lang.invoke.CallSite.type" alt="" coords="329,5,519,32"/>
<area shape="rect" id="node3" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab605e8b304dffded045540f58bab5dee" title="java.lang.invoke.MethodHandle.invoke\lWithArguments" alt="" coords="305,57,543,98"/>
<area shape="rect" id="node5" href="classjava_1_1lang_1_1invoke_1_1_method_handle_proxies.html#aa5b32d68bb74537d5ff3bc9861086923" title="java.lang.invoke.MethodHandle\lProxies.asInterfaceInstance" alt="" coords="325,122,523,163"/>
<area shape="rect" id="node6" href="classjava_1_1lang_1_1invoke_1_1_method_handles.html#aa00c85f7eacf97f8205313b7986b93eb" title="method handle modification (creation from other method handles) " alt="" coords="299,187,549,229"/>
<area shape="rect" id="node4" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#a7074b115ecbd049202f2332bdb5e9de2" title="java.lang.invoke.MethodHandle.invoke\lWithArguments" alt="" coords="597,57,836,98"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="acd7919705abc3fa4810709f3c00d1d47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final native <a class="el" href="classjava_1_1lang_1_1_object.html">Object</a> java.lang.invoke.MethodHandle.invoke </td>
          <td>(</td>
          <td class="paramtype">Object...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> throws <a class="el" href="classjava_1_1lang_1_1_throwable.html">Throwable</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invokes the method handle, allowing any caller type descriptor, and optionally performing conversions on arguments and return values. </p>
<p>If the call site's symbolic type descriptor exactly matches this method handle's <a class="el" href="">type</a>, the call proceeds as if by <a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f">invokeExact</a>. </p>
<p>Otherwise, the call proceeds as if this method handle were first adjusted by calling <a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#aa84a7dc38319aca9b668f7c061fbbfe2">asType</a> to adjust this method handle to the required type, and then the call proceeds as if by <a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f">invokeExact</a> on the adjusted method handle. </p>
<p>There is no guarantee that the</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#aa84a7dc38319aca9b668f7c061fbbfe2">asType</a> </div></div><!-- fragment --><p> call is actually made. If the JVM can predict the results of making the call, it may perform adaptations directly on the caller's arguments, and call the target method handle according to its own exact type. </p>
<p>The resolved type descriptor at the call site of</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a> </div></div><!-- fragment --><p> must be a valid argument to the receivers</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#aa84a7dc38319aca9b668f7c061fbbfe2">asType</a> </div></div><!-- fragment --><p> method. In particular, the caller must specify the same argument arity as the callee's type, if the callee is not a  #asVarargsCollector variable arity collector}. </p>
<p>When this method is observed via the Core Reflection API, it will appear as a single native method, taking an object array and returning an object. If this native method is invoked directly via <a class="el" href="classjava_1_1lang_1_1reflect_1_1_method.html#a8365954a258a062e9a5a87a78e624fbd">java.lang.reflect.Method.invoke</a>, via JNI, or indirectly via <a class="el" href="">Lookup.unreflect</a>, it will throw an</p><div class="fragment"><div class="line">UnsupportedOperationException </div></div><!-- fragment --><p> . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>the signature-polymorphic parameter list, statically represented using varargs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the signature-polymorphic result, statically represented using<div class="fragment"><div class="line">Object </div></div><!-- fragment --> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjava_1_1lang_1_1invoke_1_1_wrong_method_type_exception.html">WrongMethodTypeException</a></td><td>if the target's type cannot be adjusted to the caller's symbolic type descriptor </td></tr>
    <tr><td class="paramname"><a class="el" href="classjava_1_1lang_1_1_class_cast_exception.html">ClassCastException</a></td><td>if the target's type can be adjusted to the caller, but a reference cast fails </td></tr>
    <tr><td class="paramname"><a class="el" href="classjava_1_1lang_1_1_throwable.html">Throwable</a></td><td>anything thrown by the underlying method propagates unchanged through the method handle call </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classjava_1_1lang_1_1invoke_1_1_method_handle_acd7919705abc3fa4810709f3c00d1d47_icgraph.png" border="0" usemap="#classjava_1_1lang_1_1invoke_1_1_method_handle_acd7919705abc3fa4810709f3c00d1d47_icgraph" alt=""/></div>
<map name="classjava_1_1lang_1_1invoke_1_1_method_handle_acd7919705abc3fa4810709f3c00d1d47_icgraph" id="classjava_1_1lang_1_1invoke_1_1_method_handle_acd7919705abc3fa4810709f3c00d1d47_icgraph">
<area shape="rect" id="node2" href="classjava_1_1lang_1_1invoke_1_1_call_site.html#ac8d05a69dfddad40bbb02ea1abd0ea3e" title="java.lang.invoke.CallSite.type" alt="" coords="891,5,1082,32"/>
<area shape="rect" id="node3" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#a931494d72d8da465f6c404122e8f8e24" title="java.lang.invoke.MethodHandle.type" alt="" coords="292,60,520,87"/>
<area shape="rect" id="node4" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#aa84a7dc38319aca9b668f7c061fbbfe2" title="java.lang.invoke.MethodHandle.asType" alt="" coords="568,64,813,91"/>
<area shape="rect" id="node5" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab605e8b304dffded045540f58bab5dee" title="java.lang.invoke.MethodHandle.invoke\lWithArguments" alt="" coords="867,57,1106,98"/>
<area shape="rect" id="node7" href="classjava_1_1lang_1_1invoke_1_1_method_handle_proxies.html#aa5b32d68bb74537d5ff3bc9861086923" title="java.lang.invoke.MethodHandle\lProxies.asInterfaceInstance" alt="" coords="887,122,1086,163"/>
<area shape="rect" id="node8" href="classjava_1_1lang_1_1invoke_1_1_method_handles.html#aa00c85f7eacf97f8205313b7986b93eb" title="method handle modification (creation from other method handles) " alt="" coords="861,187,1112,229"/>
<area shape="rect" id="node6" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#a7074b115ecbd049202f2332bdb5e9de2" title="java.lang.invoke.MethodHandle.invoke\lWithArguments" alt="" coords="1160,57,1399,98"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab21540e7e42ae9b8f1ddabc286b9b57f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final native <a class="el" href="classjava_1_1lang_1_1_object.html">Object</a> java.lang.invoke.MethodHandle.invokeExact </td>
          <td>(</td>
          <td class="paramtype">Object...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> throws <a class="el" href="classjava_1_1lang_1_1_throwable.html">Throwable</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invokes the method handle, allowing any caller type descriptor, but requiring an exact type match. The symbolic type descriptor at the call site of</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f">invokeExact</a> </div></div><!-- fragment --><p> must exactly match this method handle's <a class="el" href="">type</a>. No conversions are allowed on arguments or return values. </p>
<p>When this method is observed via the Core Reflection API, it will appear as a single native method, taking an object array and returning an object. If this native method is invoked directly via <a class="el" href="classjava_1_1lang_1_1reflect_1_1_method.html#a8365954a258a062e9a5a87a78e624fbd">java.lang.reflect.Method.invoke</a>, via JNI, or indirectly via <a class="el" href="">Lookup.unreflect</a>, it will throw an</p><div class="fragment"><div class="line">UnsupportedOperationException </div></div><!-- fragment --><p> . </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>the signature-polymorphic parameter list, statically represented using varargs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the signature-polymorphic result, statically represented using<div class="fragment"><div class="line">Object </div></div><!-- fragment --> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjava_1_1lang_1_1invoke_1_1_wrong_method_type_exception.html">WrongMethodTypeException</a></td><td>if the target's type is not identical with the caller's symbolic type descriptor </td></tr>
    <tr><td class="paramname"><a class="el" href="classjava_1_1lang_1_1_throwable.html">Throwable</a></td><td>anything thrown by the underlying method propagates unchanged through the method handle call </td></tr>
  </table>
  </dd>
</dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classjava_1_1lang_1_1invoke_1_1_method_handle_ab21540e7e42ae9b8f1ddabc286b9b57f_icgraph.png" border="0" usemap="#classjava_1_1lang_1_1invoke_1_1_method_handle_ab21540e7e42ae9b8f1ddabc286b9b57f_icgraph" alt=""/></div>
<map name="classjava_1_1lang_1_1invoke_1_1_method_handle_ab21540e7e42ae9b8f1ddabc286b9b57f_icgraph" id="classjava_1_1lang_1_1invoke_1_1_method_handle_ab21540e7e42ae9b8f1ddabc286b9b57f_icgraph">
<area shape="rect" id="node2" href="classjava_1_1lang_1_1invoke_1_1_call_site.html#ac8d05a69dfddad40bbb02ea1abd0ea3e" title="java.lang.invoke.CallSite.type" alt="" coords="891,5,1082,32"/>
<area shape="rect" id="node3" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#a931494d72d8da465f6c404122e8f8e24" title="java.lang.invoke.MethodHandle.type" alt="" coords="292,60,520,87"/>
<area shape="rect" id="node4" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#aa84a7dc38319aca9b668f7c061fbbfe2" title="java.lang.invoke.MethodHandle.asType" alt="" coords="568,64,813,91"/>
<area shape="rect" id="node5" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab605e8b304dffded045540f58bab5dee" title="java.lang.invoke.MethodHandle.invoke\lWithArguments" alt="" coords="867,57,1106,98"/>
<area shape="rect" id="node7" href="classjava_1_1lang_1_1invoke_1_1_method_handle_proxies.html#aa5b32d68bb74537d5ff3bc9861086923" title="java.lang.invoke.MethodHandle\lProxies.asInterfaceInstance" alt="" coords="887,122,1086,163"/>
<area shape="rect" id="node8" href="classjava_1_1lang_1_1invoke_1_1_method_handles.html#aa00c85f7eacf97f8205313b7986b93eb" title="method handle modification (creation from other method handles) " alt="" coords="861,187,1112,229"/>
<area shape="rect" id="node6" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#a7074b115ecbd049202f2332bdb5e9de2" title="java.lang.invoke.MethodHandle.invoke\lWithArguments" alt="" coords="1160,57,1399,98"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab605e8b304dffded045540f58bab5dee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjava_1_1lang_1_1_object.html">Object</a> java.lang.invoke.MethodHandle.invokeWithArguments </td>
          <td>(</td>
          <td class="paramtype">Object...&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td> throws <a class="el" href="classjava_1_1lang_1_1_throwable.html">Throwable</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a variable arity invocation, passing the arguments in the given list to the method handle, as if via an inexact <a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a> from a call site which mentions only the type</p><div class="fragment"><div class="line">Object </div></div><!-- fragment --><p> , and whose arity is the length of the argument list. </p>
<p>Specifically, execution proceeds as if by the following steps, although the methods are not guaranteed to be called if the JVM can predict their effects. </p><ul>
<li>
Determine the length of the argument array as<div class="fragment"><div class="line">N </div></div><!-- fragment --> . For a null reference,<div class="fragment"><div class="line">N=0 </div></div><!-- fragment --> .  </li>
<li>
Determine the general type<div class="fragment"><div class="line">TN </div></div><!-- fragment --> of<div class="fragment"><div class="line">N </div></div><!-- fragment --> arguments as as<div class="fragment"><div class="line">TN=MethodType.genericMethodType(N) </div></div><!-- fragment --> . </li>
<li>
Force the original target method handle<div class="fragment"><div class="line">MH0 </div></div><!-- fragment --> to the required type, as<div class="fragment"><div class="line">MH1 = MH0.asType(TN) </div></div><!-- fragment --> .  </li>
<li>
Spread the array into<div class="fragment"><div class="line">N </div></div><!-- fragment --> separate arguments<div class="fragment"><div class="line">A0, ... </div></div><!-- fragment --> .  </li>
<li>
Invoke the type-adjusted method handle on the unpacked arguments: MH1.invokeExact(A0, ...).  </li>
<li>
Take the return value as an<div class="fragment"><div class="line">Object </div></div><!-- fragment --> reference.  </li>
</ul>
<p>Because of the action of the</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#aa84a7dc38319aca9b668f7c061fbbfe2">asType</a> </div></div><!-- fragment --><p> step, the following argument conversions are applied as necessary: </p><ul>
<li>
reference casting </li>
<li>
unboxing </li>
<li>
widening primitive conversions </li>
</ul>
<p>The result returned by the call is boxed if it is a primitive, or forced to null if the return type is void. </p>
<p>This call is equivalent to the following code: </p><blockquote class="doxtable">
<pre><div class="fragment"><div class="line">MethodHandle invoker = MethodHandles.spreadInvoker(this.<a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#a931494d72d8da465f6c404122e8f8e24">type</a>(), 0);</div><div class="line">Object result = invoker.invokeExact(<span class="keyword">this</span>, arguments);</div></div><!-- fragment --> </pre></blockquote>
<p>Unlike the signature polymorphic methods</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f">invokeExact</a> </div></div><!-- fragment --><p> and</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a> </div></div><!-- fragment --><p> , </p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab605e8b304dffded045540f58bab5dee">invokeWithArguments</a> </div></div><!-- fragment --><p> can be accessed normally via the Core Reflection API and JNI. It can therefore be used as a bridge between native or reflective code and method handles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arguments</td><td>the arguments to pass to the target </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result returned by the target </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjava_1_1lang_1_1_class_cast_exception.html">ClassCastException</a></td><td>if an argument cannot be converted by reference casting </td></tr>
    <tr><td class="paramname"><a class="el" href="classjava_1_1lang_1_1invoke_1_1_wrong_method_type_exception.html">WrongMethodTypeException</a></td><td>if the target's type cannot be adjusted to take the given number of<div class="fragment"><div class="line">Object </div></div><!-- fragment --> arguments </td></tr>
    <tr><td class="paramname"><a class="el" href="classjava_1_1lang_1_1_throwable.html">Throwable</a></td><td>anything thrown by the target method invocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handles.html#aedf6d15f26cce5931691df5e55e62f0d" title="method handle invocation (reflective style) ">MethodHandles::spreadInvoker</a> </dd></dl>

<p>Definition at line <a class="el" href="_method_handle_8java_source.html#l00625">625</a> of file <a class="el" href="_method_handle_8java_source.html">MethodHandle.java</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classjava_1_1lang_1_1invoke_1_1_method_handle_ab605e8b304dffded045540f58bab5dee_cgraph.png" border="0" usemap="#classjava_1_1lang_1_1invoke_1_1_method_handle_ab605e8b304dffded045540f58bab5dee_cgraph" alt=""/></div>
<map name="classjava_1_1lang_1_1invoke_1_1_method_handle_ab605e8b304dffded045540f58bab5dee_cgraph" id="classjava_1_1lang_1_1invoke_1_1_method_handle_ab605e8b304dffded045540f58bab5dee_cgraph">
<area shape="rect" id="node2" href="classjava_1_1lang_1_1invoke_1_1_method_type.html#a9e69c064c961f44accf7dbf9ed868c07" title="java.lang.invoke.MethodType.generic\lMethodType" alt="" coords="298,53,531,94"/>
<area shape="rect" id="node4" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#aa84a7dc38319aca9b668f7c061fbbfe2" title="java.lang.invoke.MethodHandle.asType" alt="" coords="292,199,537,225"/>
<area shape="rect" id="node3" href="classjava_1_1util_1_1_arrays.html#a15b1d34bcaa489c86a677f51c75b87c0" title="java.util.Arrays.fill" alt="" coords="663,5,785,32"/>
<area shape="rect" id="node5" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#a931494d72d8da465f6c404122e8f8e24" title="java.lang.invoke.MethodHandle.type" alt="" coords="610,56,838,83"/>
<area shape="rect" id="node8" href="classjava_1_1lang_1_1invoke_1_1_method_type.html#a4e4a2194102ad41edce4aa73073e8e7a" title="java.lang.invoke.MethodType.parameter\lCount" alt="" coords="599,107,849,149"/>
<area shape="rect" id="node9" href="classjava_1_1lang_1_1_class.html#a25ae60d66224653d22caa7cca2bfcc77" title="java.lang.Class.getComponentType" alt="" coords="611,173,837,200"/>
<area shape="rect" id="node10" href="classjava_1_1lang_1_1invoke_1_1_method_type.html#a19325cac1d745ea178301372ae91b60f" title="java.lang.invoke.MethodType.parameterType" alt="" coords="585,224,863,251"/>
<area shape="rect" id="node11" href="classjava_1_1lang_1_1_class.html#a8c180812f0af628c1aff60f6615f59b4" title="java.lang.Class.isAssignableFrom" alt="" coords="615,275,833,301"/>
<area shape="rect" id="node12" href="classjava_1_1lang_1_1_class.html#a12ec9e253bb0bc749fa0b62061b01009" title="java.lang.Class.isArray" alt="" coords="647,325,801,352"/>
<area shape="rect" id="node13" href="classjava_1_1util_1_1_arrays.html#a9136318d6e833ddd37d71718ed86a1a4" title="java.util.Arrays.asList" alt="" coords="651,376,797,403"/>
<area shape="rect" id="node6" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f" title="java.lang.invoke.MethodHandle.invoke\lExact" alt="" coords="911,19,1149,61"/>
<area shape="rect" id="node7" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47" title="java.lang.invoke.MethodHandle.invoke" alt="" coords="911,85,1149,112"/>
<area shape="rect" id="node14" href="classjava_1_1util_1_1_objects.html#a6b43262fcf49f4c1c7f4b07f4df020f8" title="java.util.Objects.require\lNonNull" alt="" coords="1441,293,1599,334"/>
<area shape="rect" id="node15" href="classjava_1_1util_1_1_arrays.html#a529c2ea0da9e1636215502e962abb3a3" title="java.util.Arrays.copyOf" alt="" coords="954,300,1106,327"/>
<area shape="rect" id="node16" href="classjava_1_1util_1_1_arrays.html#a70a18d412ed36c0b60fda282798ef22e" title="java.util.Arrays.spliterator" alt="" coords="946,351,1114,377"/>
<area shape="rect" id="node17" href="classjava_1_1util_1_1_spliterators.html#a551f8ee1706f98e800902ab580200b7e" title="java.util.Spliterators.spliterator" alt="" coords="1197,351,1393,377"/>
<area shape="rect" id="node18" href="interfacejava_1_1util_1_1function_1_1_consumer.html#a7a43b96adbff93ff90652a2816a078a6" title="java.util.function.Consumer.accept" alt="" coords="920,452,1140,479"/>
<area shape="rect" id="node19" href="classjava_1_1util_1_1_arrays.html#ae123430dd440126aa99d6bc7a294afe4" title="java.util.Arrays.sort" alt="" coords="963,503,1097,529"/>
</map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classjava_1_1lang_1_1invoke_1_1_method_handle_ab605e8b304dffded045540f58bab5dee_icgraph.png" border="0" usemap="#classjava_1_1lang_1_1invoke_1_1_method_handle_ab605e8b304dffded045540f58bab5dee_icgraph" alt=""/></div>
<map name="classjava_1_1lang_1_1invoke_1_1_method_handle_ab605e8b304dffded045540f58bab5dee_icgraph" id="classjava_1_1lang_1_1invoke_1_1_method_handle_ab605e8b304dffded045540f58bab5dee_icgraph">
<area shape="rect" id="node2" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#a7074b115ecbd049202f2332bdb5e9de2" title="java.lang.invoke.MethodHandle.invoke\lWithArguments" alt="" coords="292,5,531,47"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a7074b115ecbd049202f2332bdb5e9de2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjava_1_1lang_1_1_object.html">Object</a> java.lang.invoke.MethodHandle.invokeWithArguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfacejava_1_1util_1_1_list.html">java.util.List</a>&lt;?&gt;&#160;</td>
          <td class="paramname"><em>arguments</em></td><td>)</td>
          <td> throws <a class="el" href="classjava_1_1lang_1_1_throwable.html">Throwable</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a variable arity invocation, passing the arguments in the given array to the method handle, as if via an inexact <a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47">invoke</a> from a call site which mentions only the type</p><div class="fragment"><div class="line">Object </div></div><!-- fragment --><p> , and whose arity is the length of the argument array. </p>
<p>This method is also equivalent to the following code: </p><blockquote class="doxtable">
<pre><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab605e8b304dffded045540f58bab5dee">invokeWithArguments</a>(arguments.toArray()</div></div><!-- fragment --> </pre></blockquote>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arguments</td><td>the arguments to pass to the target </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the result returned by the target </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjava_1_1lang_1_1_null_pointer_exception.html">NullPointerException</a></td><td>if<div class="fragment"><div class="line">arguments </div></div><!-- fragment --> is a null reference </td></tr>
    <tr><td class="paramname"><a class="el" href="classjava_1_1lang_1_1_class_cast_exception.html">ClassCastException</a></td><td>if an argument cannot be converted by reference casting </td></tr>
    <tr><td class="paramname"><a class="el" href="classjava_1_1lang_1_1invoke_1_1_wrong_method_type_exception.html">WrongMethodTypeException</a></td><td>if the target's type cannot be adjusted to take the given number of<div class="fragment"><div class="line">Object </div></div><!-- fragment --> arguments </td></tr>
    <tr><td class="paramname"><a class="el" href="classjava_1_1lang_1_1_throwable.html">Throwable</a></td><td>anything thrown by the target method invocation </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_method_handle_8java_source.html#l00648">648</a> of file <a class="el" href="_method_handle_8java_source.html">MethodHandle.java</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classjava_1_1lang_1_1invoke_1_1_method_handle_a7074b115ecbd049202f2332bdb5e9de2_cgraph.png" border="0" usemap="#classjava_1_1lang_1_1invoke_1_1_method_handle_a7074b115ecbd049202f2332bdb5e9de2_cgraph" alt=""/></div>
<map name="classjava_1_1lang_1_1invoke_1_1_method_handle_a7074b115ecbd049202f2332bdb5e9de2_cgraph" id="classjava_1_1lang_1_1invoke_1_1_method_handle_a7074b115ecbd049202f2332bdb5e9de2_cgraph">
<area shape="rect" id="node2" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab605e8b304dffded045540f58bab5dee" title="java.lang.invoke.MethodHandle.invoke\lWithArguments" alt="" coords="292,122,531,163"/>
<area shape="rect" id="node3" href="classjava_1_1lang_1_1invoke_1_1_method_type.html#a9e69c064c961f44accf7dbf9ed868c07" title="java.lang.invoke.MethodType.generic\lMethodType" alt="" coords="585,53,818,94"/>
<area shape="rect" id="node5" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#aa84a7dc38319aca9b668f7c061fbbfe2" title="java.lang.invoke.MethodHandle.asType" alt="" coords="579,199,824,225"/>
<area shape="rect" id="node4" href="classjava_1_1util_1_1_arrays.html#a15b1d34bcaa489c86a677f51c75b87c0" title="java.util.Arrays.fill" alt="" coords="949,5,1072,32"/>
<area shape="rect" id="node6" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#a931494d72d8da465f6c404122e8f8e24" title="java.lang.invoke.MethodHandle.type" alt="" coords="897,56,1125,83"/>
<area shape="rect" id="node9" href="classjava_1_1lang_1_1invoke_1_1_method_type.html#a4e4a2194102ad41edce4aa73073e8e7a" title="java.lang.invoke.MethodType.parameter\lCount" alt="" coords="886,107,1135,149"/>
<area shape="rect" id="node10" href="classjava_1_1lang_1_1_class.html#a25ae60d66224653d22caa7cca2bfcc77" title="java.lang.Class.getComponentType" alt="" coords="898,173,1123,200"/>
<area shape="rect" id="node11" href="classjava_1_1lang_1_1invoke_1_1_method_type.html#a19325cac1d745ea178301372ae91b60f" title="java.lang.invoke.MethodType.parameterType" alt="" coords="872,224,1149,251"/>
<area shape="rect" id="node12" href="classjava_1_1lang_1_1_class.html#a8c180812f0af628c1aff60f6615f59b4" title="java.lang.Class.isAssignableFrom" alt="" coords="902,275,1119,301"/>
<area shape="rect" id="node13" href="classjava_1_1lang_1_1_class.html#a12ec9e253bb0bc749fa0b62061b01009" title="java.lang.Class.isArray" alt="" coords="933,325,1088,352"/>
<area shape="rect" id="node14" href="classjava_1_1util_1_1_arrays.html#a9136318d6e833ddd37d71718ed86a1a4" title="java.util.Arrays.asList" alt="" coords="937,376,1084,403"/>
<area shape="rect" id="node7" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f" title="java.lang.invoke.MethodHandle.invoke\lExact" alt="" coords="1197,19,1436,61"/>
<area shape="rect" id="node8" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47" title="java.lang.invoke.MethodHandle.invoke" alt="" coords="1197,85,1436,112"/>
<area shape="rect" id="node15" href="classjava_1_1util_1_1_objects.html#a6b43262fcf49f4c1c7f4b07f4df020f8" title="java.util.Objects.require\lNonNull" alt="" coords="1728,293,1885,334"/>
<area shape="rect" id="node16" href="classjava_1_1util_1_1_arrays.html#a529c2ea0da9e1636215502e962abb3a3" title="java.util.Arrays.copyOf" alt="" coords="1241,300,1393,327"/>
<area shape="rect" id="node17" href="classjava_1_1util_1_1_arrays.html#a70a18d412ed36c0b60fda282798ef22e" title="java.util.Arrays.spliterator" alt="" coords="1233,351,1401,377"/>
<area shape="rect" id="node18" href="classjava_1_1util_1_1_spliterators.html#a551f8ee1706f98e800902ab580200b7e" title="java.util.Spliterators.spliterator" alt="" coords="1484,351,1680,377"/>
<area shape="rect" id="node19" href="interfacejava_1_1util_1_1function_1_1_consumer.html#a7a43b96adbff93ff90652a2816a078a6" title="java.util.function.Consumer.accept" alt="" coords="1207,452,1427,479"/>
<area shape="rect" id="node20" href="classjava_1_1util_1_1_arrays.html#ae123430dd440126aa99d6bc7a294afe4" title="java.util.Arrays.sort" alt="" coords="1250,503,1383,529"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a931494d72d8da465f6c404122e8f8e24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjava_1_1lang_1_1invoke_1_1_method_type.html">MethodType</a> java.lang.invoke.MethodHandle.type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reports the type of this method handle. Every invocation of this method handle via</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f">invokeExact</a> </div></div><!-- fragment --><p> must exactly match this type. </p><dl class="section return"><dt>Returns</dt><dd>the method handle type </dd></dl>

<p>Definition at line <a class="el" href="_method_handle_8java_source.html#l00445">445</a> of file <a class="el" href="_method_handle_8java_source.html">MethodHandle.java</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classjava_1_1lang_1_1invoke_1_1_method_handle_a931494d72d8da465f6c404122e8f8e24_cgraph.png" border="0" usemap="#classjava_1_1lang_1_1invoke_1_1_method_handle_a931494d72d8da465f6c404122e8f8e24_cgraph" alt=""/></div>
<map name="classjava_1_1lang_1_1invoke_1_1_method_handle_a931494d72d8da465f6c404122e8f8e24_cgraph" id="classjava_1_1lang_1_1invoke_1_1_method_handle_a931494d72d8da465f6c404122e8f8e24_cgraph">
<area shape="rect" id="node2" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab21540e7e42ae9b8f1ddabc286b9b57f" title="java.lang.invoke.MethodHandle.invoke\lExact" alt="" coords="281,5,520,47"/>
<area shape="rect" id="node3" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#acd7919705abc3fa4810709f3c00d1d47" title="java.lang.invoke.MethodHandle.invoke" alt="" coords="281,71,520,98"/>
</map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classjava_1_1lang_1_1invoke_1_1_method_handle_a931494d72d8da465f6c404122e8f8e24_icgraph.png" border="0" usemap="#classjava_1_1lang_1_1invoke_1_1_method_handle_a931494d72d8da465f6c404122e8f8e24_icgraph" alt=""/></div>
<map name="classjava_1_1lang_1_1invoke_1_1_method_handle_a931494d72d8da465f6c404122e8f8e24_icgraph" id="classjava_1_1lang_1_1invoke_1_1_method_handle_a931494d72d8da465f6c404122e8f8e24_icgraph">
<area shape="rect" id="node2" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#aa84a7dc38319aca9b668f7c061fbbfe2" title="java.lang.invoke.MethodHandle.asType" alt="" coords="281,97,527,124"/>
<area shape="rect" id="node3" href="classjava_1_1lang_1_1invoke_1_1_call_site.html#ac8d05a69dfddad40bbb02ea1abd0ea3e" title="java.lang.invoke.CallSite.type" alt="" coords="605,5,795,32"/>
<area shape="rect" id="node4" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#ab605e8b304dffded045540f58bab5dee" title="java.lang.invoke.MethodHandle.invoke\lWithArguments" alt="" coords="581,57,819,98"/>
<area shape="rect" id="node6" href="classjava_1_1lang_1_1invoke_1_1_method_handle_proxies.html#aa5b32d68bb74537d5ff3bc9861086923" title="java.lang.invoke.MethodHandle\lProxies.asInterfaceInstance" alt="" coords="601,122,799,163"/>
<area shape="rect" id="node7" href="classjava_1_1lang_1_1invoke_1_1_method_handles.html#aa00c85f7eacf97f8205313b7986b93eb" title="method handle modification (creation from other method handles) " alt="" coords="575,187,825,229"/>
<area shape="rect" id="node5" href="classjava_1_1lang_1_1invoke_1_1_method_handle.html#a7074b115ecbd049202f2332bdb5e9de2" title="java.lang.invoke.MethodHandle.invoke\lWithArguments" alt="" coords="873,57,1112,98"/>
</map>
</div>
</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>E:/00_Code/openjdk8/java/lang/invoke/<a class="el" href="_method_handle_8java_source.html">MethodHandle.java</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
