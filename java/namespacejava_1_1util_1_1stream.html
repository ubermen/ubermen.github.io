<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>openjdk8_analysis: Package java.util.stream</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">openjdk8_analysis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Packages</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacejava.html">java</a></li><li class="navelem"><a class="el" href="namespacejava_1_1util.html">util</a></li><li class="navelem"><a class="el" href="namespacejava_1_1util_1_1stream.html">stream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Package java.util.stream</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>AbstractPipeline</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>AbstractShortCircuitTask</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>AbstractSpinedBuffer</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>AbstractTask</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacejava_1_1util_1_1stream_1_1_base_stream.html">BaseStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacejava_1_1util_1_1stream_1_1_collector.html">Collector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1stream_1_1_collectors.html">Collectors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>DistinctOps</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacejava_1_1util_1_1stream_1_1_double_stream.html">DoubleStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>FindOps</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>ForEachOps</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacejava_1_1util_1_1stream_1_1_int_stream.html">IntStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacejava_1_1util_1_1stream_1_1_long_stream.html">LongStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>MatchOps</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><b>Node</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Nodes</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>PipelineHelper</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>ReduceOps</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>ReferencePipeline</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><b>Sink</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>SliceOps</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>SortedOps</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>SpinedBuffer</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacejava_1_1util_1_1stream_1_1_stream.html">Stream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>StreamOpFlag</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Streams</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>StreamShape</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>StreamSpliterators</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1stream_1_1_stream_support.html">StreamSupport</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><b>TerminalOp</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><b>TerminalSink</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Tripwire</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Classes to support functional-style operations on streams of elements, such as map-reduce transformations on collections. For example:</p>
<pre><div class="fragment"><div class="line"><span class="keywordtype">int</span> sum = widgets.stream()</div><div class="line">                 .filter(b -&gt; b.getColor() == RED)</div><div class="line">                 .mapToInt(b -&gt; b.getWeight())</div><div class="line">                 .sum();</div></div><!-- fragment --> </pre><p>Here we use</p><div class="fragment"><div class="line">widgets </div></div><!-- fragment --><p> , a</p><div class="fragment"><div class="line">Collection&lt;Widget&gt; </div></div><!-- fragment --><p> , as a source for a stream, and then perform a filter-map-reduce on the stream to obtain the sum of the weights of the red widgets. (Summation is an example of a <a href="package-summary.html#Reduction">reduction</a> operation.)</p>
<p>The key abstraction introduced in this package is <em>stream</em>. The classes <a class="el" href="interfacejava_1_1util_1_1stream_1_1_stream.html">java.util.stream.Stream</a>, <a class="el" href="interfacejava_1_1util_1_1stream_1_1_int_stream.html">java.util.stream.IntStream</a>, <a class="el" href="interfacejava_1_1util_1_1stream_1_1_long_stream.html">java.util.stream.LongStream</a>, and <a class="el" href="interfacejava_1_1util_1_1stream_1_1_double_stream.html">java.util.stream.DoubleStream</a> are streams over objects and the primitive</p><div class="fragment"><div class="line"><span class="keywordtype">int</span> </div></div><!-- fragment --><p> ,</p><div class="fragment"><div class="line"><span class="keywordtype">long</span> </div></div><!-- fragment --><p> and </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> </div></div><!-- fragment --><p> types. Streams differ from collections in several ways:</p>
<ul>
<li>
No storage. A stream is not a data structure that stores elements; instead, it conveys elements from a source such as a data structure, an array, a generator function, or an I/O channel, through a pipeline of computational operations. </li>
<li>
Functional in nature. An operation on a stream produces a result, but does not modify its source. For example, filtering a<div class="fragment"><div class="line">Stream </div></div><!-- fragment --> obtained from a collection produces a new<div class="fragment"><div class="line">Stream </div></div><!-- fragment --> without the filtered elements, rather than removing elements from the source collection. </li>
<li>
Laziness-seeking. Many stream operations, such as filtering, mapping, or duplicate removal, can be implemented lazily, exposing opportunities for optimization. For example, "find the first@code String @endcode  with
    three consecutive vowels" need not examine all the input strings. <a class="el" href="interfacejava_1_1util_1_1stream_1_1_stream.html">Stream</a> operations are divided into intermediate (<div class="fragment"><div class="line">Stream </div></div><!-- fragment --> -producing) operations and terminal (value- or side-effect-producing) operations. Intermediate operations are always lazy. </li>
<li>
Possibly unbounded. While collections have a finite size, streams need not. Short-circuiting operations such as<div class="fragment"><div class="line">limit(n) </div></div><!-- fragment --> or <div class="fragment"><div class="line">findFirst() </div></div><!-- fragment --> can allow computations on infinite streams to complete in finite time. </li>
<li>
Consumable. The elements of a stream are only visited once during the life of a stream. Like an <a class="el" href="interfacejava_1_1util_1_1_iterator.html">java.util.Iterator</a>, a new stream must be generated to revisit the same elements of the source.  </li>
</ul>
<p>Streams can be obtained in a number of ways. Some examples include: </p><ul>
<li>
From a <a class="el" href="interfacejava_1_1util_1_1_collection.html">java.util.Collection</a> via the<div class="fragment"><div class="line">stream() </div></div><!-- fragment --> and <div class="fragment"><div class="line">parallelStream() </div></div><!-- fragment --> methods; </li>
<li>
From an array via <a class="el" href="">java.util.Arrays#stream(Object[])</a>; </li>
<li>
From static factory methods on the stream classes, such as <a class="el" href="">java.util.stream.Stream#of(Object[])</a>, <a class="el" href="interfacejava_1_1util_1_1stream_1_1_int_stream.html#ab39a2c1b77637f9b8ccbdfb96d17fca2">java.util.stream.IntStream#range(int, int)</a> or <a class="el" href="">java.util.stream.Stream#iterate(Object, UnaryOperator)</a>; </li>
<li>
The lines of a file can be obtained from <a class="el" href="classjava_1_1io_1_1_buffered_reader.html#adc3f8277ed25fcb854b95dccccec2be4">java.io.BufferedReader#lines()</a>; </li>
<li>
Streams of file paths can be obtained from methods in <a class="el" href="classjava_1_1nio_1_1file_1_1_files.html">java.nio.file.Files</a>; </li>
<li>
Streams of random numbers can be obtained from <a class="el" href="classjava_1_1util_1_1_random.html#a5222f4306609566984a07b58b158db0b">java.util.Random#ints()</a>; </li>
<li>
Numerous other stream-bearing methods in the JDK, including <a class="el" href="classjava_1_1util_1_1_bit_set.html#adbf896033ee065fbe5b6ae3da82953c9">java.util.BitSet#stream()</a>, <a class="el" href="">java.util.regex.Pattern#splitAsStream(java.lang.CharSequence)</a>, and <a class="el" href="classjava_1_1util_1_1jar_1_1_jar_file.html#a74b965ba8aca3cc1c943f3f135a33471">java.util.jar.JarFile#stream()</a>. </li>
</ul>
<p>Additional stream sources can be provided by third-party libraries using <a href="package-summary.html#StreamSources">these techniques</a>.</p>
<h2><a class="anchor" id="StreamOps"></a><a class="el" href="interfacejava_1_1util_1_1stream_1_1_stream.html">Stream</a> operations and pipelines</h2>
<p><a class="el" href="interfacejava_1_1util_1_1stream_1_1_stream.html">Stream</a> operations are divided into <em>intermediate</em> and <em>terminal</em> operations, and are combined to form <em>stream pipelines</em>. A stream pipeline consists of a source (such as a </p><div class="fragment"><div class="line">Collection </div></div><!-- fragment --><p> , an array, a generator function, or an I/O channel); followed by zero or more intermediate operations such as </p><div class="fragment"><div class="line">Stream.filter </div></div><!-- fragment --><p> or</p><div class="fragment"><div class="line">Stream.map </div></div><!-- fragment --><p> ; and a terminal operation such as</p><div class="fragment"><div class="line">Stream.forEach </div></div><!-- fragment --><p> or</p><div class="fragment"><div class="line">Stream.reduce </div></div><!-- fragment --><p> .</p>
<p>Intermediate operations return a new stream. They are always <em>lazy</em>; executing an intermediate operation such as </p><div class="fragment"><div class="line">filter() </div></div><!-- fragment --><p> does not actually perform any filtering, but instead creates a new stream that, when traversed, contains the elements of the initial stream that match the given predicate. Traversal of the pipeline source does not begin until the terminal operation of the pipeline is executed.</p>
<p>Terminal operations, such as</p><div class="fragment"><div class="line">Stream.forEach </div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line">IntStream.sum </div></div><!-- fragment --><p> , may traverse the stream to produce a result or a side-effect. After the terminal operation is performed, the stream pipeline is considered consumed, and can no longer be used; if you need to traverse the same data source again, you must return to the data source to get a new stream. In almost all cases, terminal operations are <em>eager</em>, completing their traversal of the data source and processing of the pipeline before returning. Only the terminal operations</p><div class="fragment"><div class="line">iterator() </div></div><!-- fragment --><p> and </p><div class="fragment"><div class="line">spliterator() </div></div><!-- fragment --><p> are not; these are provided as an "escape hatch" to enable arbitrary client-controlled pipeline traversals in the event that the existing operations are not sufficient to the task.</p>
<p>Processing streams lazily allows for significant efficiencies; in a pipeline such as the filter-map-sum example above, filtering, mapping, and summing can be fused into a single pass on the data, with minimal intermediate state. Laziness also allows avoiding examining all the data when it is not necessary; for operations such as "find the first string
longer than 1000 characters", it is only necessary to examine just enough strings to find one that has the desired characteristics without examining all of the strings available from the source. (This behavior becomes even more important when the input stream is infinite and not merely large.)</p>
<p>Intermediate operations are further divided into <em>stateless</em> and <em>stateful</em> operations. Stateless operations, such as</p><div class="fragment"><div class="line">filter </div></div><!-- fragment --><p> and</p><div class="fragment"><div class="line">map </div></div><!-- fragment --><p> , retain no state from previously seen element when processing a new element &ndash; each element can be processed independently of operations on other elements. Stateful operations, such as </p><div class="fragment"><div class="line">distinct </div></div><!-- fragment --><p> and</p><div class="fragment"><div class="line">sorted </div></div><!-- fragment --><p> , may incorporate state from previously seen elements when processing new elements.</p>
<p>Stateful operations may need to process the entire input before producing a result. For example, one cannot produce any results from sorting a stream until one has seen all elements of the stream. As a result, under parallel computation, some pipelines containing stateful intermediate operations may require multiple passes on the data or may need to buffer significant data. Pipelines containing exclusively stateless intermediate operations can be processed in a single pass, whether sequential or parallel, with minimal data buffering.</p>
<p>Further, some operations are deemed <em>short-circuiting</em> operations. An intermediate operation is short-circuiting if, when presented with infinite input, it may produce a finite stream as a result. A terminal operation is short-circuiting if, when presented with infinite input, it may terminate in finite time. Having a short-circuiting operation in the pipeline is a necessary, but not sufficient, condition for the processing of an infinite stream to terminate normally in finite time.</p>
<h3>Parallelism</h3>
<p>Processing elements with an explicit</p><div class="fragment"><div class="line"><span class="keywordflow">for</span>- </div></div><!-- fragment --><p> loop is inherently serial. Streams facilitate parallel execution by reframing the computation as a pipeline of aggregate operations, rather than as imperative operations on each individual element. All streams operations can execute either in serial or in parallel. The stream implementations in the JDK create serial streams unless parallelism is explicitly requested. For example,</p><div class="fragment"><div class="line">Collection </div></div><!-- fragment --><p> has methods <a class="el" href="interfacejava_1_1util_1_1_collection.html#a8df09ae175dd587f56741064929fb1c7">java.util.Collection#stream</a> and <a class="el" href="interfacejava_1_1util_1_1_collection.html#a83dc9f774595d91560bb1870df05c738">java.util.Collection#parallelStream</a>, which produce sequential and parallel streams respectively; other stream-bearing methods such as <a class="el" href="interfacejava_1_1util_1_1stream_1_1_int_stream.html#ab39a2c1b77637f9b8ccbdfb96d17fca2">java.util.stream.IntStream#range(int, int)</a> produce sequential streams but these streams can be efficiently parallelized by invoking their <a class="el" href="interfacejava_1_1util_1_1stream_1_1_base_stream.html#ac890829f43c2360b3d2a5e92be4e7023">java.util.stream.BaseStream#parallel()</a> method. To execute the prior "sum of weights of widgets" query in parallel, we would do:</p>
<pre><div class="fragment"><div class="line"><span class="keywordtype">int</span> sumOfWeights = widgets. </div></div><!-- fragment --> <code><b>parallelStream()</b></code><div class="fragment"><div class="line">.filter(b -&gt; b.getColor() == RED)</div><div class="line">.mapToInt(b -&gt; b.getWeight())</div><div class="line">.sum();</div></div><!-- fragment --> </pre><p>The only difference between the serial and parallel versions of this example is the creation of the initial stream, using "@code parallelStream() @endcode " instead of "@code stream() @endcode ". When the terminal operation is initiated, the stream pipeline is executed sequentially or in parallel depending on the orientation of the stream on which it is invoked. Whether a stream will execute in serial or parallel can be determined with the</p><div class="fragment"><div class="line">isParallel() </div></div><!-- fragment --><p> method, and the orientation of a stream can be modified with the <a class="el" href="interfacejava_1_1util_1_1stream_1_1_base_stream.html#a139cf37005d755d7c8e8e0f0f0630ff3">java.util.stream.BaseStream#sequential()</a> and <a class="el" href="interfacejava_1_1util_1_1stream_1_1_base_stream.html#ac890829f43c2360b3d2a5e92be4e7023">java.util.stream.BaseStream#parallel()</a> operations. When the terminal operation is initiated, the stream pipeline is executed sequentially or in parallel depending on the mode of the stream on which it is invoked.</p>
<p>Except for operations identified as explicitly nondeterministic, such as</p><div class="fragment"><div class="line">findAny() </div></div><!-- fragment --><p> , whether a stream executes sequentially or in parallel should not change the result of the computation.</p>
<p>Most stream operations accept parameters that describe user-specified behavior, which are often lambda expressions. To preserve correct behavior, these <em>behavioral parameters</em> must be <em>non-interfering</em>, and in most cases must be <em>stateless</em>. Such parameters are always instances of a <a href="../function/package-summary.html">functional interface</a> such as <a class="el" href="interfacejava_1_1util_1_1function_1_1_function.html">java.util.function.Function</a>, and are often lambda expressions or method references.</p>
<h3><a class="anchor" id="NonInterference"></a>Non-interference</h3>
<p>Streams enable you to execute possibly-parallel aggregate operations over a variety of data sources, including even non-thread-safe collections such as </p><div class="fragment"><div class="line">ArrayList </div></div><!-- fragment --><p> . This is possible only if we can prevent <em>interference</em> with the data source during the execution of a stream pipeline. Except for the escape-hatch operations</p><div class="fragment"><div class="line">iterator() </div></div><!-- fragment --><p> and </p><div class="fragment"><div class="line">spliterator() </div></div><!-- fragment --><p> , execution begins when the terminal operation is invoked, and ends when the terminal operation completes. For most data sources, preventing interference means ensuring that the data source is <em>not modified at all</em> during the execution of the stream pipeline. The notable exception to this are streams whose sources are concurrent collections, which are specifically designed to handle concurrent modification. Concurrent stream sources are those whose</p><div class="fragment"><div class="line">Spliterator </div></div><!-- fragment --><p> reports the </p><div class="fragment"><div class="line">CONCURRENT </div></div><!-- fragment --><p> characteristic.</p>
<p>Accordingly, behavioral parameters in stream pipelines whose source might not be concurrent should never modify the stream's data source. A behavioral parameter is said to <em>interfere</em> with a non-concurrent data source if it modifies, or causes to be modified, the stream's data source. The need for non-interference applies to all pipelines, not just parallel ones. Unless the stream source is concurrent, modifying a stream's data source during execution of a stream pipeline can cause exceptions, incorrect answers, or nonconformant behavior.</p>
<p>For well-behaved stream sources, the source can be modified before the terminal operation commences and those modifications will be reflected in the covered elements. For example, consider the following code:</p>
<pre><div class="fragment"><div class="line">List&lt;String&gt; l = <span class="keyword">new</span> ArrayList(Arrays.asList(<span class="stringliteral">&quot;one&quot;</span>, <span class="stringliteral">&quot;two&quot;</span>));</div><div class="line">Stream&lt;String&gt; sl = l.stream();</div><div class="line">l.add(<span class="stringliteral">&quot;three&quot;</span>);</div><div class="line">String s = sl.collect(joining(<span class="stringliteral">&quot; &quot;</span>));</div></div><!-- fragment --> </pre><p>First a list is created consisting of two strings: "one"; and "two". Then a stream is created from that list. Next the list is modified by adding a third string: "three". Finally the elements of the stream are collected and joined together. Since the list was modified before the terminal</p><div class="fragment"><div class="line">collect </div></div><!-- fragment --><p> operation commenced the result will be a string of "one two three". All the streams returned from JDK collections, and most other JDK classes, are well-behaved in this manner; for streams generated by other libraries, see <a href="package-summary.html#StreamSources">Low-level stream construction</a> for requirements for building well-behaved streams.</p>
<h3><a class="anchor" id="Statelessness"></a>Stateless behaviors</h3>
<p><a class="el" href="interfacejava_1_1util_1_1stream_1_1_stream.html">Stream</a> pipeline results may be nondeterministic or incorrect if the behavioral parameters to the stream operations are <em>stateful</em>. A stateful lambda (or other object implementing the appropriate functional interface) is one whose result depends on any state which might change during the execution of the stream pipeline. An example of a stateful lambda is the parameter to</p><div class="fragment"><div class="line">map() </div></div><!-- fragment --><p> in:</p>
<pre><div class="fragment"><div class="line">Set&lt;Integer&gt; seen = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">stream.parallel().map(e -&gt; { <span class="keywordflow">if</span> (seen.add(e)) <span class="keywordflow">return</span> 0; <span class="keywordflow">else</span> <span class="keywordflow">return</span> e; })...</div></div><!-- fragment --> </pre><p>Here, if the mapping operation is performed in parallel, the results for the same input could vary from run to run, due to thread scheduling differences, whereas, with a stateless lambda expression the results would always be the same.</p>
<p>Note also that attempting to access mutable state from behavioral parameters presents you with a bad choice with respect to safety and performance; if you do not synchronize access to that state, you have a data race and therefore your code is broken, but if you do synchronize access to that state, you risk having contention undermine the parallelism you are seeking to benefit from. The best approach is to avoid stateful behavioral parameters to stream operations entirely; there is usually a way to restructure the stream pipeline to avoid statefulness.</p>
<h3>Side-effects</h3>
<p>Side-effects in behavioral parameters to stream operations are, in general, discouraged, as they can often lead to unwitting violations of the statelessness requirement, as well as other thread-safety hazards.</p>
<p>If the behavioral parameters do have side-effects, unless explicitly stated, there are no guarantees as to the <a href="../concurrent/package-summary.html#MemoryVisibility"><em>visibility</em></a> of those side-effects to other threads, nor are there any guarantees that different operations on the "same" element within the same stream pipeline are executed in the same thread. Further, the ordering of those effects may be surprising. Even when a pipeline is constrained to produce a <em>result</em> that is consistent with the encounter order of the stream source (for example,</p><div class="fragment"><div class="line">IntStream.range(0,5).parallel().map(x -&gt; x*2).toArray() </div></div><!-- fragment --><p> must produce</p><div class="fragment"><div class="line">[0, 2, 4, 6, 8] </div></div><!-- fragment --><p> ), no guarantees are made as to the order in which the mapper function is applied to individual elements, or in what thread any behavioral parameter is executed for a given element.</p>
<p>Many computations where one might be tempted to use side effects can be more safely and efficiently expressed without side-effects, such as using <a href="package-summary.html#Reduction">reduction</a> instead of mutable accumulators. However, side-effects such as using</p><div class="fragment"><div class="line">println() </div></div><!-- fragment --><p> for debugging purposes are usually harmless. A small number of stream operations, such as </p><div class="fragment"><div class="line">forEach() </div></div><!-- fragment --><p> and</p><div class="fragment"><div class="line">peek() </div></div><!-- fragment --><p> , can operate only via side-effects; these should be used with care.</p>
<p>As an example of how to transform a stream pipeline that inappropriately uses side-effects to one that does not, the following code searches a stream of strings for those matching a given regular expression, and puts the matches in a list.</p>
<pre><div class="fragment"><div class="line">ArrayList&lt;String&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">stream.filter(s -&gt; pattern.matcher(s).matches())</div><div class="line">      .forEach(s -&gt; results.add(s));  <span class="comment">// Unnecessary use of side-effects!</span></div></div><!-- fragment --> </pre><p>This code unnecessarily uses side-effects. If executed in parallel, the non-thread-safety of</p><div class="fragment"><div class="line">ArrayList </div></div><!-- fragment --><p> would cause incorrect results, and adding needed synchronization would cause contention, undermining the benefit of parallelism. Furthermore, using side-effects here is completely unnecessary; the</p><div class="fragment"><div class="line">forEach() </div></div><!-- fragment --><p> can simply be replaced with a reduction operation that is safer, more efficient, and more amenable to parallelization:</p>
<pre><div class="fragment"><div class="line">List&lt;String&gt;results =</div><div class="line">    stream.filter(s -&gt; pattern.matcher(s).matches())</div><div class="line">          .collect(Collectors.toList());  <span class="comment">// No side-effects!</span></div></div><!-- fragment --> </pre><h3><a class="anchor" id="Ordering"></a>Ordering</h3>
<p>Streams may or may not have a defined <em>encounter order</em>. Whether or not a stream has an encounter order depends on the source and the intermediate operations. Certain stream sources (such as</p><div class="fragment"><div class="line">List </div></div><!-- fragment --><p> or arrays) are intrinsically ordered, whereas others (such as</p><div class="fragment"><div class="line">HashSet </div></div><!-- fragment --><p> ) are not. Some intermediate operations, such as</p><div class="fragment"><div class="line">sorted() </div></div><!-- fragment --><p> , may impose an encounter order on an otherwise unordered stream, and others may render an ordered stream unordered, such as <a class="el" href="interfacejava_1_1util_1_1stream_1_1_base_stream.html#af71fd5e3f84185322947633d3671f064">java.util.stream.BaseStream#unordered()</a>. Further, some terminal operations may ignore encounter order, such as </p><div class="fragment"><div class="line">forEach() </div></div><!-- fragment --><p> .</p>
<p>If a stream is ordered, most operations are constrained to operate on the elements in their encounter order; if the source of a stream is a</p><div class="fragment"><div class="line">List </div></div><!-- fragment --><p> containing</p><div class="fragment"><div class="line">[1, 2, 3] </div></div><!-- fragment --><p> , then the result of executing</p><div class="fragment"><div class="line">map(x -&gt; x*2) </div></div><!-- fragment --><p> must be</p><div class="fragment"><div class="line">[2, 4, 6] </div></div><!-- fragment --><p> . However, if the source has no defined encounter order, then any permutation of the values</p><div class="fragment"><div class="line">[2, 4, 6] </div></div><!-- fragment --><p> would be a valid result.</p>
<p>For sequential streams, the presence or absence of an encounter order does not affect performance, only determinism. If a stream is ordered, repeated execution of identical stream pipelines on an identical source will produce an identical result; if it is not ordered, repeated execution might produce different results.</p>
<p>For parallel streams, relaxing the ordering constraint can sometimes enable more efficient execution. Certain aggregate operations, such as filtering duplicates (</p><div class="fragment"><div class="line">distinct() </div></div><!-- fragment --><p> ) or grouped reductions (</p><div class="fragment"><div class="line">Collectors.groupingBy() </div></div><!-- fragment --><p> ) can be implemented more efficiently if ordering of elements is not relevant. Similarly, operations that are intrinsically tied to encounter order, such as</p><div class="fragment"><div class="line">limit() </div></div><!-- fragment --><p> , may require buffering to ensure proper ordering, undermining the benefit of parallelism. In cases where the stream has an encounter order, but the user does not particularly <em>care</em> about that encounter order, explicitly de-ordering the stream with <a class="el" href="interfacejava_1_1util_1_1stream_1_1_base_stream.html#af71fd5e3f84185322947633d3671f064">unordered()</a> may improve parallel performance for some stateful or terminal operations. However, most stream pipelines, such as the "sum of weight of blocks" example above, still parallelize efficiently even under ordering constraints.</p>
<h2><a class="anchor" id="Reduction"></a>Reduction operations</h2>
<p>A <em>reduction</em> operation (also called a <em>fold</em>) takes a sequence of input elements and combines them into a single summary result by repeated application of a combining operation, such as finding the sum or maximum of a set of numbers, or accumulating elements into a list. The streams classes have multiple forms of general reduction operations, called <a class="el" href="">reduce()</a> and <a class="el" href="">collect()</a>, as well as multiple specialized reduction forms such as <a class="el" href="interfacejava_1_1util_1_1stream_1_1_int_stream.html#a04e919a3c83258a4b375ca849bc91bbb">sum()</a>, <a class="el" href="interfacejava_1_1util_1_1stream_1_1_int_stream.html#a57273c130fcc36cd8950371d86f43667">max()</a>, or <a class="el" href="interfacejava_1_1util_1_1stream_1_1_int_stream.html#a5864097f5c2396f8b171e5e7c910b403">count()</a>.</p>
<p>Of course, such operations can be readily implemented as simple sequential loops, as in: </p><pre><div class="fragment"><div class="line"><span class="keywordtype">int</span> sum = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> x : numbers) {</div><div class="line">   sum += x;</div><div class="line">}</div></div><!-- fragment --> </pre><p> However, there are good reasons to prefer a reduce operation over a mutative accumulation such as the above. Not only is a reduction "more abstract" &ndash; it operates on the stream as a whole rather than individual elements &ndash; but a properly constructed reduce operation is inherently parallelizable, so long as the function(s) used to process the elements are <a href="package-summary.html#Associativity">associative</a> and <a href="package-summary.html#NonInterfering">stateless</a>. For example, given a stream of numbers for which we want to find the sum, we can write: </p><pre><div class="fragment"><div class="line"><span class="keywordtype">int</span> sum = numbers.stream().reduce(0, (x,y) -&gt; x+y);</div></div><!-- fragment --> </pre><p> or: </p><pre><div class="fragment"><div class="line"><span class="keywordtype">int</span> sum = numbers.stream().reduce(0, Integer::sum);</div></div><!-- fragment --> </pre><p>These reduction operations can run safely in parallel with almost no modification: </p><pre><div class="fragment"><div class="line"><span class="keywordtype">int</span> sum = numbers.parallelStream().reduce(0, Integer::sum);</div></div><!-- fragment --> </pre><p>Reduction parallellizes well because the implementation can operate on subsets of the data in parallel, and then combine the intermediate results to get the final correct answer. (Even if the language had a "parallel for-each" construct, the mutative accumulation approach would still required the developer to provide thread-safe updates to the shared accumulating variable</p><div class="fragment"><div class="line">sum </div></div><!-- fragment --><p> , and the required synchronization would then likely eliminate any performance gain from parallelism.) Using</p><div class="fragment"><div class="line">reduce() </div></div><!-- fragment --><p> instead removes all of the burden of parallelizing the reduction operation, and the library can provide an efficient parallel implementation with no additional synchronization required.</p>
<p>The "widgets" examples shown earlier shows how reduction combines with other operations to replace for loops with bulk operations. If</p><div class="fragment"><div class="line">widgets </div></div><!-- fragment --><p> is a collection of</p><div class="fragment"><div class="line">Widget </div></div><!-- fragment --><p> objects, which have a</p><div class="fragment"><div class="line">getWeight </div></div><!-- fragment --><p> method, we can find the heaviest widget with: </p><pre><div class="fragment"><div class="line">OptionalInt heaviest = widgets.parallelStream()</div><div class="line">                              .mapToInt(Widget::getWeight)</div><div class="line">                              .max();</div></div><!-- fragment --> </pre><p>In its more general form, a</p><div class="fragment"><div class="line">reduce </div></div><!-- fragment --><p> operation on elements of type </p><div class="fragment"><div class="line">&lt;T&gt; </div></div><!-- fragment --><p> yielding a result of type</p><div class="fragment"><div class="line">&lt;U&gt; </div></div><!-- fragment --><p> requires three parameters: </p><pre><div class="fragment"><div class="line">&lt;U&gt; U reduce(U identity,</div><div class="line">             BiFunction&lt;U, ? super T, U&gt; accumulator,</div><div class="line">             BinaryOperator&lt;U&gt; combiner);</div></div><!-- fragment --> </pre><p> Here, the <em>identity</em> element is both an initial seed value for the reduction and a default result if there are no input elements. The <em>accumulator</em> function takes a partial result and the next element, and produces a new partial result. The <em>combiner</em> function combines two partial results to produce a new partial result. (The combiner is necessary in parallel reductions, where the input is partitioned, a partial accumulation computed for each partition, and then the partial results are combined to produce a final result.)</p>
<p>More formally, the</p><div class="fragment"><div class="line">identity </div></div><!-- fragment --><p> value must be an <em>identity</em> for the combiner function. This means that for all</p><div class="fragment"><div class="line">u </div></div><!-- fragment --><p> , </p><div class="fragment"><div class="line">combiner.apply(identity, u) </div></div><!-- fragment --><p> is equal to</p><div class="fragment"><div class="line">u </div></div><!-- fragment --><p> . Additionally, the </p><div class="fragment"><div class="line">combiner </div></div><!-- fragment --><p> function must be <a href="package-summary.html#Associativity">associative</a> and must be compatible with the</p><div class="fragment"><div class="line">accumulator </div></div><!-- fragment --><p> function: for all</p><div class="fragment"><div class="line">u </div></div><!-- fragment --><p> and</p><div class="fragment"><div class="line">t </div></div><!-- fragment --><p> ,</p><div class="fragment"><div class="line">combiner.apply(u, accumulator.apply(identity, t)) </div></div><!-- fragment --><p> must be</p><div class="fragment"><div class="line">equals() </div></div><!-- fragment --><p> to</p><div class="fragment"><div class="line">accumulator.apply(u, t) </div></div><!-- fragment --><p> .</p>
<p>The three-argument form is a generalization of the two-argument form, incorporating a mapping step into the accumulation step. We could re-cast the simple sum-of-weights example using the more general form as follows: </p><pre><div class="fragment"><div class="line"><span class="keywordtype">int</span> sumOfWeights = widgets.stream()</div><div class="line">                          .reduce(0,</div><div class="line">                                  (sum, b) -&gt; sum + b.getWeight())</div><div class="line">                                  Integer::sum);</div></div><!-- fragment --> </pre><p> though the explicit map-reduce form is more readable and therefore should usually be preferred. The generalized form is provided for cases where significant work can be optimized away by combining mapping and reducing into a single function.</p>
<h3><a class="anchor" id="MutableReduction"></a>Mutable reduction</h3>
<p>A <em>mutable reduction operation</em> accumulates input elements into a mutable result container, such as a</p><div class="fragment"><div class="line">Collection </div></div><!-- fragment --><p> or</p><div class="fragment"><div class="line">StringBuilder </div></div><!-- fragment --><p> , as it processes the elements in the stream.</p>
<p>If we wanted to take a stream of strings and concatenate them into a single long string, we <em>could</em> achieve this with ordinary reduction: </p><pre><div class="fragment"><div class="line">String concatenated = strings.reduce(<span class="stringliteral">&quot;&quot;</span>, String::concat)</div></div><!-- fragment --> </pre><p>We would get the desired result, and it would even work in parallel. However, we might not be happy about the performance! Such an implementation would do a great deal of string copying, and the run time would be <em>O(n^2)</em> in the number of characters. A more performant approach would be to accumulate the results into a <a class="el" href="classjava_1_1lang_1_1_string_builder.html">java.lang.StringBuilder</a>, which is a mutable container for accumulating strings. We can use the same technique to parallelize mutable reduction as we do with ordinary reduction.</p>
<p>The mutable reduction operation is called <a class="el" href="">collect()</a>, as it collects together the desired results into a result container such as a</p><div class="fragment"><div class="line">Collection </div></div><!-- fragment --><p> . A</p><div class="fragment"><div class="line">collect </div></div><!-- fragment --><p> operation requires three functions: a supplier function to construct new instances of the result container, an accumulator function to incorporate an input element into a result container, and a combining function to merge the contents of one result container into another. The form of this is very similar to the general form of ordinary reduction: </p><pre><div class="fragment"><div class="line">&lt;R&gt; R collect(Supplier&lt;R&gt; supplier,</div><div class="line">              BiConsumer&lt;R, ? super T&gt; accumulator,</div><div class="line">              BiConsumer&lt;R, R&gt; combiner);</div></div><!-- fragment --> </pre> <p>As with</p><div class="fragment"><div class="line">reduce() </div></div><!-- fragment --><p> , a benefit of expressing</p><div class="fragment"><div class="line">collect </div></div><!-- fragment --><p> in this abstract way is that it is directly amenable to parallelization: we can accumulate partial results in parallel and then combine them, so long as the accumulation and combining functions satisfy the appropriate requirements. For example, to collect the String representations of the elements in a stream into an</p><div class="fragment"><div class="line">ArrayList </div></div><!-- fragment --><p> , we could write the obvious sequential for-each form: </p><pre><div class="fragment"><div class="line">ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="keywordflow">for</span> (T element : stream) {</div><div class="line">    strings.add(element.toString());</div><div class="line">}</div></div><!-- fragment --> </pre><p> Or we could use a parallelizable collect form: </p><pre><div class="fragment"><div class="line">ArrayList&lt;String&gt; strings = stream.collect(() -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;(),</div><div class="line">                                           (c, e) -&gt; c.add(e.toString()),</div><div class="line">                                           (c1, c2) -&gt; c1.addAll(c2));</div></div><!-- fragment --> </pre><p> or, pulling the mapping operation out of the accumulator function, we could express it more succinctly as: </p><pre><div class="fragment"><div class="line">List&lt;String&gt; strings = stream.map(Object::toString)</div><div class="line">                             .collect(ArrayList::new, <a class="code" href="classjava_1_1util_1_1_array_list.html#abd6c83f9b52fc889760c0ac0eeeb3514">ArrayList::add</a>, <a class="code" href="classjava_1_1util_1_1_array_list.html#a72b829e83fdd4869a3b4343995833007">ArrayList::addAll</a>);</div></div><!-- fragment --> </pre><p> Here, our supplier is just the <a class="el" href="classjava_1_1util_1_1_array_list.html#a50fb40ee9ef69183738251e7f613301e">ArrayList constructor</a>, the accumulator adds the stringified element to an </p><div class="fragment"><div class="line">ArrayList </div></div><!-- fragment --><p> , and the combiner simply uses <a class="el" href="classjava_1_1util_1_1_array_list.html#a72b829e83fdd4869a3b4343995833007">addAll</a> to copy the strings from one container into the other.</p>
<p>The three aspects of</p><div class="fragment"><div class="line">collect </div></div><!-- fragment --><p> &ndash; supplier, accumulator, and combiner &ndash; are tightly coupled. We can use the abstraction of a <a class="el" href="interfacejava_1_1util_1_1stream_1_1_collector.html">java.util.stream.Collector</a> to capture all three aspects. The above example for collecting strings into a</p><div class="fragment"><div class="line">List </div></div><!-- fragment --><p> can be rewritten using a standard</p><div class="fragment"><div class="line">Collector </div></div><!-- fragment --><p> as: </p><pre><div class="fragment"><div class="line">List&lt;String&gt; strings = stream.map(Object::toString)</div><div class="line">                             .collect(Collectors.toList());</div></div><!-- fragment --> </pre><p>Packaging mutable reductions into a <a class="el" href="interfacejava_1_1util_1_1stream_1_1_collector.html">Collector</a> has another advantage: composability. The class <a class="el" href="classjava_1_1util_1_1stream_1_1_collectors.html">java.util.stream.Collectors</a> contains a number of predefined factories for collectors, including combinators that transform one collector into another. For example, suppose we have a collector that computes the sum of the salaries of a stream of employees, as follows:</p>
<pre><div class="fragment"><div class="line">Collector&lt;Employee, ?, Integer&gt; summingSalaries</div><div class="line">    = Collectors.summingInt(Employee::getSalary);</div></div><!-- fragment --> </pre><p>(The</p><div class="fragment"><div class="line">? </div></div><!-- fragment --><p> for the second type parameter merely indicates that we don't care about the intermediate representation used by this collector.) If we wanted to create a collector to tabulate the sum of salaries by department, we could reuse</p><div class="fragment"><div class="line">summingSalaries </div></div><!-- fragment --><p> using <a class="el" href="">groupingBy</a>:</p>
<pre><div class="fragment"><div class="line">Map&lt;Department, Integer&gt; salariesByDept</div><div class="line">    = employees.stream().collect(Collectors.groupingBy(Employee::getDepartment,</div><div class="line">                                                       summingSalaries));</div></div><!-- fragment --> </pre><p>As with the regular reduction operation,</p><div class="fragment"><div class="line">collect() </div></div><!-- fragment --><p> operations can only be parallelized if appropriate conditions are met. For any partially accumulated result, combining it with an empty result container must produce an equivalent result. That is, for a partially accumulated result </p><div class="fragment"><div class="line">p </div></div><!-- fragment --><p> that is the result of any series of accumulator and combiner invocations,</p><div class="fragment"><div class="line">p </div></div><!-- fragment --><p> must be equivalent to </p><div class="fragment"><div class="line">combiner.apply(p, supplier.get()) </div></div><!-- fragment --><p> .</p>
<p>Further, however the computation is split, it must produce an equivalent result. For any input elements</p><div class="fragment"><div class="line">t1 </div></div><!-- fragment --><p> and</p><div class="fragment"><div class="line">t2 </div></div><!-- fragment --><p> , the results </p><div class="fragment"><div class="line">r1 </div></div><!-- fragment --><p> and</p><div class="fragment"><div class="line">r2 </div></div><!-- fragment --><p> in the computation below must be equivalent: </p><pre><div class="fragment"><div class="line">A a1 = supplier.get();</div><div class="line">accumulator.accept(a1, t1);</div><div class="line">accumulator.accept(a1, t2);</div><div class="line">R r1 = finisher.apply(a1);  <span class="comment">// result without splitting</span></div><div class="line"></div><div class="line">A a2 = supplier.get();</div><div class="line">accumulator.accept(a2, t1);</div><div class="line">A a3 = supplier.get();</div><div class="line">accumulator.accept(a3, t2);</div><div class="line">R r2 = finisher.apply(combiner.apply(a2, a3));  <span class="comment">// result with splitting</span></div></div><!-- fragment --> </pre><p>Here, equivalence generally means according to <a class="el" href="classjava_1_1lang_1_1_object.html#aec614df0334131693f88adcbb1065465">java.lang.Object#equals(Object)</a>. but in some cases equivalence may be relaxed to account for differences in order.</p>
<h3><a class="anchor" id="ConcurrentReduction"></a>Reduction, concurrency, and ordering</h3>
<p>With some complex reduction operations, for example a</p><div class="fragment"><div class="line">collect() </div></div><!-- fragment --><p> that produces a</p><div class="fragment"><div class="line">Map </div></div><!-- fragment --><p> , such as: </p><pre><div class="fragment"><div class="line">Map&lt;Buyer, List&lt;Transaction&gt;&gt; salesByBuyer</div><div class="line">    = txns.parallelStream()</div><div class="line">          .collect(Collectors.groupingBy(Transaction::getBuyer));</div></div><!-- fragment --> </pre><p> it may actually be counterproductive to perform the operation in parallel. This is because the combining step (merging one</p><div class="fragment"><div class="line">Map </div></div><!-- fragment --><p> into another by key) can be expensive for some</p><div class="fragment"><div class="line">Map </div></div><!-- fragment --><p> implementations.</p>
<p>Suppose, however, that the result container used in this reduction was a concurrently modifiable collection &ndash; such as a <a class="el" href="classjava_1_1util_1_1concurrent_1_1_concurrent_hash_map.html">java.util.concurrent.ConcurrentHashMap</a>. In that case, the parallel invocations of the accumulator could actually deposit their results concurrently into the same shared result container, eliminating the need for the combiner to merge distinct result containers. This potentially provides a boost to the parallel execution performance. We call this a <em>concurrent</em> reduction.</p>
<p>A <a class="el" href="interfacejava_1_1util_1_1stream_1_1_collector.html">java.util.stream.Collector</a> that supports concurrent reduction is marked with the <a class="el" href="enumjava_1_1util_1_1stream_1_1_collector_1_1_characteristics.html#af097b6127394fb1960c223c83a27e707">java.util.stream.Collector.Characteristics#CONCURRENT</a> characteristic. However, a concurrent collection also has a downside. If multiple threads are depositing results concurrently into a shared container, the order in which results are deposited is non-deterministic. Consequently, a concurrent reduction is only possible if ordering is not important for the stream being processed. The <a class="el" href="">java.util.stream.Stream#collect(Collector)</a> implementation will only perform a concurrent reduction if </p><ul>
<li>
The stream is parallel; </li>
<li>
The collector has the <a class="el" href="enumjava_1_1util_1_1stream_1_1_collector_1_1_characteristics.html#af097b6127394fb1960c223c83a27e707">java.util.stream.Collector.Characteristics#CONCURRENT</a> characteristic, and; </li>
<li>
Either the stream is unordered, or the collector has the <a class="el" href="enumjava_1_1util_1_1stream_1_1_collector_1_1_characteristics.html#ab0ed42a1001d84ad11d00a36d11876fb">java.util.stream.Collector.Characteristics#UNORDERED</a> characteristic. </li>
</ul>
<p>You can ensure the stream is unordered by using the <a class="el" href="interfacejava_1_1util_1_1stream_1_1_base_stream.html#af71fd5e3f84185322947633d3671f064">java.util.stream.BaseStream#unordered()</a> method. For example: </p><pre><div class="fragment"><div class="line">Map&lt;Buyer, List&lt;Transaction&gt;&gt; salesByBuyer</div><div class="line">    = txns.parallelStream()</div><div class="line">          .unordered()</div><div class="line">          .collect(groupingByConcurrent(Transaction::getBuyer));</div></div><!-- fragment --> </pre><p> (where <a class="el" href="classjava_1_1util_1_1stream_1_1_collectors.html#ac9a3bb743b64f96e15a29d9b5781ef68">java.util.stream.Collectors#groupingByConcurrent</a> is the concurrent equivalent of</p><div class="fragment"><div class="line">groupingBy </div></div><!-- fragment --><p> ).</p>
<p>Note that if it is important that the elements for a given key appear in the order they appear in the source, then we cannot use a concurrent reduction, as ordering is one of the casualties of concurrent insertion. We would then be constrained to implement either a sequential reduction or a merge-based parallel reduction.</p>
<h3><a class="anchor" id="Associativity"></a>Associativity</h3>
<p>An operator or function</p><div class="fragment"><div class="line">op </div></div><!-- fragment --><p> is <em>associative</em> if the following holds: </p><pre><div class="fragment"><div class="line">(a op b) op c == a op (b op c)</div></div><!-- fragment --> </pre><p> The importance of this to parallel evaluation can be seen if we expand this to four terms: </p><pre><div class="fragment"><div class="line">a op b op c op d == (a op b) op (c op d)</div></div><!-- fragment --> </pre><p> So we can evaluate</p><div class="fragment"><div class="line">(a op b) </div></div><!-- fragment --><p> in parallel with</p><div class="fragment"><div class="line">(c op d) </div></div><!-- fragment --><p> , and then invoke</p><div class="fragment"><div class="line">op </div></div><!-- fragment --><p> on the results.</p>
<p>Examples of associative operations include numeric addition, min, and max, and string concatenation.</p>
<h2><a class="anchor" id="StreamSources"></a>Low-level stream construction</h2>
<p>So far, all the stream examples have used methods like <a class="el" href="interfacejava_1_1util_1_1_collection.html#a8df09ae175dd587f56741064929fb1c7">java.util.Collection#stream()</a> or <a class="el" href="">java.util.Arrays#stream(Object[])</a> to obtain a stream. How are those stream-bearing methods implemented?</p>
<p>The class <a class="el" href="classjava_1_1util_1_1stream_1_1_stream_support.html">java.util.stream.StreamSupport</a> has a number of low-level methods for creating a stream, all using some form of a <a class="el" href="interfacejava_1_1util_1_1_spliterator.html">java.util.Spliterator</a>. A spliterator is the parallel analogue of an <a class="el" href="interfacejava_1_1util_1_1_iterator.html">java.util.Iterator</a>; it describes a (possibly infinite) collection of elements, with support for sequentially advancing, bulk traversal, and splitting off some portion of the input into another spliterator which can be processed in parallel. At the lowest level, all streams are driven by a spliterator.</p>
<p>There are a number of implementation choices in implementing a spliterator, nearly all of which are tradeoffs between simplicity of implementation and runtime performance of streams using that spliterator. The simplest, but least performant, way to create a spliterator is to create one from an iterator using <a class="el" href="">java.util.Spliterators#spliteratorUnknownSize(java.util.Iterator, int)</a>. While such a spliterator will work, it will likely offer poor parallel performance, since we have lost sizing information (how big is the underlying data set), as well as being constrained to a simplistic splitting algorithm.</p>
<p>A higher-quality spliterator will provide balanced and known-size splits, accurate sizing information, and a number of other <a class="el" href="interfacejava_1_1util_1_1_spliterator.html#a557cc90aa0ee3ecc9472f7d1cb32c870">characteristics</a> of the spliterator or data that can be used by implementations to optimize execution.</p>
<p><a class="el" href="classjava_1_1util_1_1_spliterators.html">Spliterators</a> for mutable data sources have an additional challenge; timing of binding to the data, since the data could change between the time the spliterator is created and the time the stream pipeline is executed. Ideally, a spliterator for a stream would report a characteristic of</p>
<div class="fragment"><div class="line">IMMUTABLE </div></div><!-- fragment --><p> or</p><div class="fragment"><div class="line">CONCURRENT </div></div><!-- fragment --><p> ; if not it should be <a href="../Spliterator.html#binding"><em>late-binding</em></a>. If a source cannot directly supply a recommended spliterator, it may indirectly supply a spliterator using a</p><div class="fragment"><div class="line">Supplier </div></div><!-- fragment --><p> , and construct a stream via the </p><div class="fragment"><div class="line">Supplier </div></div><!-- fragment --><p> -accepting versions of <a class="el" href="">stream()</a>. The spliterator is obtained from the supplier only after the terminal operation of the stream pipeline commences.</p>
<p>These requirements significantly reduce the scope of potential interference between mutations of the stream source and execution of stream pipelines. Streams based on spliterators with the desired characteristics, or those using the Supplier-based factory forms, are immune to modifications of the data source prior to commencement of the terminal operation (provided the behavioral parameters to the stream operations meet the required criteria for non-interference and statelessness). See <a href="package-summary.html#NonInterference">Non-Interference</a> for more details.</p>
<dl class="section since"><dt>Since</dt><dd>1.8 </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
