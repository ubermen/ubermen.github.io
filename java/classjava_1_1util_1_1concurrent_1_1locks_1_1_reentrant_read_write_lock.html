<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>openjdk8_analysis: java.util.concurrent.locks.ReentrantReadWriteLock Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">openjdk8_analysis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacejava.html">java</a></li><li class="navelem"><a class="el" href="namespacejava_1_1util.html">util</a></li><li class="navelem"><a class="el" href="namespacejava_1_1util_1_1concurrent.html">concurrent</a></li><li class="navelem"><a class="el" href="namespacejava_1_1util_1_1concurrent_1_1locks.html">locks</a></li><li class="navelem"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html">ReentrantReadWriteLock</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">java.util.concurrent.locks.ReentrantReadWriteLock Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for java.util.concurrent.locks.ReentrantReadWriteLock:</div>
<div class="dyncontent">
<div class="center"><img src="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock__inherit__graph.png" border="0" usemap="#java_8util_8concurrent_8locks_8_reentrant_read_write_lock_inherit__map" alt="Inheritance graph"/></div>
<map name="java_8util_8concurrent_8locks_8_reentrant_read_write_lock_inherit__map" id="java_8util_8concurrent_8locks_8_reentrant_read_write_lock_inherit__map">
<area shape="rect" id="node2" href="interfacejava_1_1util_1_1concurrent_1_1locks_1_1_read_write_lock.html" title="java.util.concurrent.locks.\lReadWriteLock" alt="" coords="5,5,175,47"/>
<area shape="rect" id="node3" href="interfacejava_1_1io_1_1_serializable.html" title="java.io.Serializable" alt="" coords="199,13,328,39"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for java.util.concurrent.locks.ReentrantReadWriteLock:</div>
<div class="dyncontent">
<div class="center"><img src="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock__coll__graph.png" border="0" usemap="#java_8util_8concurrent_8locks_8_reentrant_read_write_lock_coll__map" alt="Collaboration graph"/></div>
<map name="java_8util_8concurrent_8locks_8_reentrant_read_write_lock_coll__map" id="java_8util_8concurrent_8locks_8_reentrant_read_write_lock_coll__map">
<area shape="rect" id="node2" href="interfacejava_1_1util_1_1concurrent_1_1locks_1_1_read_write_lock.html" title="java.util.concurrent.locks.\lReadWriteLock" alt="" coords="688,5,857,47"/>
<area shape="rect" id="node3" href="interfacejava_1_1io_1_1_serializable.html" title="java.io.Serializable" alt="" coords="5,122,135,149"/>
<area shape="rect" id="node5" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_abstract_queued_synchronizer.html" title="java.util.concurrent.locks.\lAbstractQueuedSynchronizer" alt="" coords="431,123,623,164"/>
<area shape="rect" id="node6" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_abstract_ownable_synchronizer.html" title="java.util.concurrent.locks.\lAbstractOwnableSynchronizer" alt="" coords="184,173,381,215"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>FairSync</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>NonfairSync</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>ReadLock</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Sync</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>WriteLock</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adcb6f79ed1e1d4dd0618adc489998803"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#adcb6f79ed1e1d4dd0618adc489998803">ReentrantReadWriteLock</a> ()</td></tr>
<tr class="separator:adcb6f79ed1e1d4dd0618adc489998803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181e744578e96e8314271ff30a0121c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a181e744578e96e8314271ff30a0121c6">ReentrantReadWriteLock</a> (boolean fair)</td></tr>
<tr class="separator:a181e744578e96e8314271ff30a0121c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c19d8265947415fc44b364229445df"><td class="memItemLeft" align="right" valign="top">ReentrantReadWriteLock.WriteLock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a85c19d8265947415fc44b364229445df">writeLock</a> ()</td></tr>
<tr class="separator:a85c19d8265947415fc44b364229445df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0a965da93f54be0abd5693db560763"><td class="memItemLeft" align="right" valign="top">ReentrantReadWriteLock.ReadLock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a6b0a965da93f54be0abd5693db560763">readLock</a> ()</td></tr>
<tr class="separator:a6b0a965da93f54be0abd5693db560763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba945e3874c9a27122bfb9563bdd14ed"><td class="memItemLeft" align="right" valign="top">final boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#aba945e3874c9a27122bfb9563bdd14ed">isFair</a> ()</td></tr>
<tr class="separator:aba945e3874c9a27122bfb9563bdd14ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee7216cc9a7dc1a184c3fad51066a27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a0ee7216cc9a7dc1a184c3fad51066a27">getReadLockCount</a> ()</td></tr>
<tr class="separator:a0ee7216cc9a7dc1a184c3fad51066a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36eeeab82a6e391efa778aa20b747b42"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a36eeeab82a6e391efa778aa20b747b42">isWriteLocked</a> ()</td></tr>
<tr class="separator:a36eeeab82a6e391efa778aa20b747b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e83e72a0eeca1519ff833c6b57d6b3c"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a1e83e72a0eeca1519ff833c6b57d6b3c">isWriteLockedByCurrentThread</a> ()</td></tr>
<tr class="separator:a1e83e72a0eeca1519ff833c6b57d6b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8910fa648c0ea134e33590a7b1730d57"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a8910fa648c0ea134e33590a7b1730d57">getWriteHoldCount</a> ()</td></tr>
<tr class="separator:a8910fa648c0ea134e33590a7b1730d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1345e2584e0de498cd9f309f3c388fbd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a1345e2584e0de498cd9f309f3c388fbd">getReadHoldCount</a> ()</td></tr>
<tr class="separator:a1345e2584e0de498cd9f309f3c388fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57eb2d2caca547ffa6e4a5fb61a19af7"><td class="memItemLeft" align="right" valign="top">final boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a57eb2d2caca547ffa6e4a5fb61a19af7">hasQueuedThreads</a> ()</td></tr>
<tr class="separator:a57eb2d2caca547ffa6e4a5fb61a19af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1927fe8dc2fccedb9300ab16525b6b46"><td class="memItemLeft" align="right" valign="top">final boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a1927fe8dc2fccedb9300ab16525b6b46">hasQueuedThread</a> (Thread thread)</td></tr>
<tr class="separator:a1927fe8dc2fccedb9300ab16525b6b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c757912c80d92c08ac853c1f5e6aba2"><td class="memItemLeft" align="right" valign="top">final int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a5c757912c80d92c08ac853c1f5e6aba2">getQueueLength</a> ()</td></tr>
<tr class="separator:a5c757912c80d92c08ac853c1f5e6aba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93166dce2b63dbf102c6787ea290e6a0"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a93166dce2b63dbf102c6787ea290e6a0">hasWaiters</a> (<a class="el" href="interfacejava_1_1util_1_1concurrent_1_1locks_1_1_condition.html">Condition</a> condition)</td></tr>
<tr class="separator:a93166dce2b63dbf102c6787ea290e6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d6ea26f2bd360198a55318332e6449e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a2d6ea26f2bd360198a55318332e6449e">getWaitQueueLength</a> (<a class="el" href="interfacejava_1_1util_1_1concurrent_1_1locks_1_1_condition.html">Condition</a> condition)</td></tr>
<tr class="separator:a2d6ea26f2bd360198a55318332e6449e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0456f201308ee5876f17c93447cc9639"><td class="memItemLeft" align="right" valign="top">String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a0456f201308ee5876f17c93447cc9639">toString</a> ()</td></tr>
<tr class="separator:a0456f201308ee5876f17c93447cc9639"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8cc563c210e82fa8054b24e376127aca"><td class="memItemLeft" align="right" valign="top">Thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a8cc563c210e82fa8054b24e376127aca">getOwner</a> ()</td></tr>
<tr class="separator:a8cc563c210e82fa8054b24e376127aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4e8d00cb8d50e944323e373f145c97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfacejava_1_1util_1_1_collection.html">Collection</a>&lt; Thread &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a2c4e8d00cb8d50e944323e373f145c97">getQueuedWriterThreads</a> ()</td></tr>
<tr class="separator:a2c4e8d00cb8d50e944323e373f145c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a106781c305c1ec2ba6f77edcf9df32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfacejava_1_1util_1_1_collection.html">Collection</a>&lt; Thread &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a9a106781c305c1ec2ba6f77edcf9df32">getQueuedReaderThreads</a> ()</td></tr>
<tr class="separator:a9a106781c305c1ec2ba6f77edcf9df32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02bf7b06a332a01cbe68654e079341f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfacejava_1_1util_1_1_collection.html">Collection</a>&lt; Thread &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a02bf7b06a332a01cbe68654e079341f7">getQueuedThreads</a> ()</td></tr>
<tr class="separator:a02bf7b06a332a01cbe68654e079341f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe04c040b9242b98847bb9954fc4c67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfacejava_1_1util_1_1_collection.html">Collection</a>&lt; Thread &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#abfe04c040b9242b98847bb9954fc4c67">getWaitingThreads</a> (<a class="el" href="interfacejava_1_1util_1_1concurrent_1_1locks_1_1_condition.html">Condition</a> condition)</td></tr>
<tr class="separator:abfe04c040b9242b98847bb9954fc4c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An implementation of <a class="el" href="interfacejava_1_1util_1_1concurrent_1_1locks_1_1_read_write_lock.html">ReadWriteLock</a> supporting similar semantics to <a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_lock.html">ReentrantLock</a>. </p>
<p>This class has the following properties:</p>
<ul>
<li>
<p class="startli"><b>Acquisition order</b></p>
<p></p>
<p>This class does not impose a reader or writer preference ordering for lock access. However, it does support an optional <em>fairness</em> policy.</p>
<dl>
<dt><b><em>Non-fair mode (default)</em></b> </dt>
<dd><p class="startdd">When constructed as non-fair (the default), the order of entry to the read and write lock is unspecified, subject to reentrancy constraints. A nonfair lock that is continuously contended may indefinitely postpone one or more reader or writer threads, but will normally have higher throughput than a fair lock.</p>
<p class="enddd"></p>
</dd>
<dt><b><em>Fair mode</em></b> </dt>
<dd><p class="startdd">When constructed as fair, threads contend for entry using an approximately arrival-order policy. When the currently held lock is released, either the longest-waiting single writer thread will be assigned the write lock, or if there is a group of reader threads waiting longer than all waiting writer threads, that group will be assigned the read lock.</p>
<p></p>
<p>A thread that tries to acquire a fair read lock (non-reentrantly) will block if either the write lock is held, or there is a waiting writer thread. The thread will not acquire the read lock until after the oldest currently waiting writer thread has acquired and released the write lock. Of course, if a waiting writer abandons its wait, leaving one or more reader threads as the longest waiters in the queue with the write lock free, then those readers will be assigned the read lock.</p>
<p></p>
<p>A thread that tries to acquire a fair write lock (non-reentrantly) will block unless both the read lock and write lock are free (which implies there are no waiting threads). (Note that the non-blocking <a class="el" href="">ReadLock#tryLock()</a> and <a class="el" href="">WriteLock#tryLock()</a> methods do not honor this fair setting and will immediately acquire the lock if it is possible, regardless of waiting threads.) </p>
<p class="enddd"></p>
</dd>
</dl>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Reentrancy</b></p>
<p></p>
<p>This lock allows both readers and writers to reacquire read or write locks in the style of a <a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_lock.html">ReentrantLock</a>. Non-reentrant readers are not allowed until all write locks held by the writing thread have been released.</p>
<p></p>
<p>Additionally, a writer can acquire the read lock, but not vice-versa. Among other applications, reentrancy can be useful when write locks are held during calls or callbacks to methods that perform reads under read locks. If a reader tries to acquire the write lock it will never succeed.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b><a class="el" href="interfacejava_1_1util_1_1concurrent_1_1locks_1_1_lock.html">Lock</a> downgrading</b> </p>
<p>Reentrancy also allows downgrading from the write lock to a read lock, by acquiring the write lock, then the read lock and then releasing the write lock. However, upgrading from a read lock to the write lock is <b>not</b> possible.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Interruption of lock acquisition</b> </p>
<p>The read lock and write lock both support interruption during lock acquisition.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b><a class="el" href="interfacejava_1_1util_1_1concurrent_1_1locks_1_1_condition.html">Condition</a> support</b> </p>
<p>The write lock provides a <a class="el" href="interfacejava_1_1util_1_1concurrent_1_1locks_1_1_condition.html">Condition</a> implementation that behaves in the same way, with respect to the write lock, as the <a class="el" href="interfacejava_1_1util_1_1concurrent_1_1locks_1_1_condition.html">Condition</a> implementation provided by <a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_lock.html#a43433d60cf3d24c322522fda0196c0ad">ReentrantLock#newCondition</a> does for <a class="el" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_lock.html">ReentrantLock</a>. This <a class="el" href="interfacejava_1_1util_1_1concurrent_1_1locks_1_1_condition.html">Condition</a> can, of course, only be used with the write lock.</p>
<p></p>
<p>The read lock does not support a <a class="el" href="interfacejava_1_1util_1_1concurrent_1_1locks_1_1_condition.html">Condition</a> and </p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a6b0a965da93f54be0abd5693db560763">readLock</a>().newCondition() </div></div><!-- fragment --><p> throws </p><div class="fragment"><div class="line">UnsupportedOperationException </div></div><!-- fragment --><p> .</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><b>Instrumentation</b> </p>
<p class="endli">This class supports methods to determine whether locks are held or contended. These methods are designed for monitoring system state, not for synchronization control. </p>
</li>
</ul>
<p>Serialization of this class behaves in the same way as built-in locks: a deserialized lock is in the unlocked state, regardless of its state when serialized.</p>
<p><b>Sample usages</b>. Here is a code sketch showing how to perform lock downgrading after updating a cache (exception handling is particularly tricky when handling multiple locks in a non-nested fashion):</p>
<pre><div class="fragment"><div class="line"><span class="keyword">class </span>CachedData {</div><div class="line">  Object data;</div><div class="line">  <span class="keyword">volatile</span> <span class="keywordtype">boolean</span> cacheValid;</div><div class="line">  <span class="keyword">final</span> <a class="code" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#adcb6f79ed1e1d4dd0618adc489998803">ReentrantReadWriteLock</a> rwl = <span class="keyword">new</span> <a class="code" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#adcb6f79ed1e1d4dd0618adc489998803">ReentrantReadWriteLock</a>();</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> processCachedData() {</div><div class="line">    rwl.readLock().lock();</div><div class="line">    <span class="keywordflow">if</span> (!cacheValid) {</div><div class="line">      <span class="comment">// Must release read lock before acquiring write lock</span></div><div class="line">      rwl.readLock().unlock();</div><div class="line">      rwl.writeLock().lock();</div><div class="line">      <span class="keywordflow">try</span> {</div><div class="line">        <span class="comment">// Recheck state because another thread might have</span></div><div class="line">        <span class="comment">// acquired write lock and changed state before we did.</span></div><div class="line">        <span class="keywordflow">if</span> (!cacheValid) {</div><div class="line">          data = ...</div><div class="line">          cacheValid = <span class="keyword">true</span>;</div><div class="line">        }</div><div class="line">        <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></div><div class="line">        rwl.readLock().lock();</div><div class="line">      } <span class="keywordflow">finally</span> {</div><div class="line">        rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></div><div class="line">      }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">try</span> {</div><div class="line">      use(data);</div><div class="line">    } <span class="keywordflow">finally</span> {</div><div class="line">      rwl.readLock().unlock();</div><div class="line">    }</div><div class="line">  }</div><div class="line">} </div></div><!-- fragment --> </pre><p>ReentrantReadWriteLocks can be used to improve concurrency in some uses of some kinds of <a class="el" href="classjava_1_1util_1_1_collections.html">Collections</a>. This is typically worthwhile only when the collections are expected to be large, accessed by more reader threads than writer threads, and entail operations with overhead that outweighs synchronization overhead. For example, here is a class using a <a class="el" href="classjava_1_1util_1_1_tree_map.html">TreeMap</a> that is expected to be large and concurrently accessed.</p>
<pre><div class="fragment"><div class="line"><span class="keyword">class </span>RWDictionary {</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Data&gt; m = <span class="keyword">new</span> TreeMap&lt;String, Data&gt;();</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <a class="code" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#adcb6f79ed1e1d4dd0618adc489998803">ReentrantReadWriteLock</a> rwl = <span class="keyword">new</span> <a class="code" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#adcb6f79ed1e1d4dd0618adc489998803">ReentrantReadWriteLock</a>();</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock r = rwl.readLock();</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock w = rwl.writeLock();</div><div class="line"></div><div class="line">  <span class="keyword">public</span> Data <span class="keyword">get</span>(String key) {</div><div class="line">    r.lock();</div><div class="line">    <span class="keywordflow">try</span> { <span class="keywordflow">return</span> m.get(key); }</div><div class="line">    <span class="keywordflow">finally</span> { r.unlock(); }</div><div class="line">  }</div><div class="line">  <span class="keyword">public</span> String[] allKeys() {</div><div class="line">    r.lock();</div><div class="line">    <span class="keywordflow">try</span> { <span class="keywordflow">return</span> m.keySet().toArray(); }</div><div class="line">    <span class="keywordflow">finally</span> { r.unlock(); }</div><div class="line">  }</div><div class="line">  <span class="keyword">public</span> Data put(String key, Data value) {</div><div class="line">    w.lock();</div><div class="line">    <span class="keywordflow">try</span> { <span class="keywordflow">return</span> m.put(key, value); }</div><div class="line">    <span class="keywordflow">finally</span> { w.unlock(); }</div><div class="line">  }</div><div class="line">  <span class="keyword">public</span> <span class="keywordtype">void</span> clear() {</div><div class="line">    w.lock();</div><div class="line">    <span class="keywordflow">try</span> { m.clear(); }</div><div class="line">    <span class="keywordflow">finally</span> { w.unlock(); }</div><div class="line">  }</div><div class="line">} </div></div><!-- fragment --> </pre><h3>Implementation Notes</h3>
<p>This lock supports a maximum of 65535 recursive write locks and 65535 read locks. Attempts to exceed these limits result in <a class="el" href="">Error</a> throws from locking methods.</p>
<dl class="section since"><dt>Since</dt><dd>1.5 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Doug Lea </dd></dl>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l00215">215</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adcb6f79ed1e1d4dd0618adc489998803"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">java.util.concurrent.locks.ReentrantReadWriteLock.ReentrantReadWriteLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#adcb6f79ed1e1d4dd0618adc489998803">ReentrantReadWriteLock</a> </div></div><!-- fragment --><p> with default (nonfair) ordering properties. </p>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l00229">229</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>

</div>
</div>
<a class="anchor" id="a181e744578e96e8314271ff30a0121c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">java.util.concurrent.locks.ReentrantReadWriteLock.ReentrantReadWriteLock </td>
          <td>(</td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>fair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new</p><div class="fragment"><div class="line"><a class="code" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#adcb6f79ed1e1d4dd0618adc489998803">ReentrantReadWriteLock</a> </div></div><!-- fragment --><p> with the given fairness policy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fair</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l00239">239</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a8cc563c210e82fa8054b24e376127aca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Thread java.util.concurrent.locks.ReentrantReadWriteLock.getOwner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the thread that currently owns the write lock, or </p><div class="fragment"><div class="line">null </div></div><!-- fragment --><p> if not owned. When this method is called by a thread that is not the owner, the return value reflects a best-effort approximation of current lock status. For example, the owner may be momentarily</p><div class="fragment"><div class="line">null </div></div><!-- fragment --><p> even if there are threads trying to acquire the lock but have not yet done so. This method is designed to facilitate construction of subclasses that provide more extensive lock monitoring facilities.</p>
<dl class="section return"><dt>Returns</dt><dd>the owner, or<div class="fragment"><div class="line">null </div></div><!-- fragment --> if not owned </dd></dl>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l01248">1248</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a8cc563c210e82fa8054b24e376127aca_icgraph.png" border="0" usemap="#classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a8cc563c210e82fa8054b24e376127aca_icgraph" alt=""/></div>
<map name="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a8cc563c210e82fa8054b24e376127aca_icgraph" id="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a8cc563c210e82fa8054b24e376127aca_icgraph">
<area shape="rect" id="node2" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a6b0a965da93f54be0abd5693db560763" title="java.util.concurrent.locks.\lReentrantReadWriteLock.readLock" alt="" coords="280,5,504,47"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a9a106781c305c1ec2ba6f77edcf9df32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfacejava_1_1util_1_1_collection.html">Collection</a>&lt;Thread&gt; java.util.concurrent.locks.ReentrantReadWriteLock.getQueuedReaderThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a collection containing threads that may be waiting to acquire the read lock. Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order. This method is designed to facilitate construction of subclasses that provide more extensive lock monitoring facilities.</p>
<dl class="section return"><dt>Returns</dt><dd>the collection of threads </dd></dl>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l01335">1335</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>

</div>
</div>
<a class="anchor" id="a02bf7b06a332a01cbe68654e079341f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfacejava_1_1util_1_1_collection.html">Collection</a>&lt;Thread&gt; java.util.concurrent.locks.ReentrantReadWriteLock.getQueuedThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a collection containing threads that may be waiting to acquire either the read or write lock. Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order. This method is designed to facilitate construction of subclasses that provide more extensive monitoring facilities.</p>
<dl class="section return"><dt>Returns</dt><dd>the collection of threads </dd></dl>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l01393">1393</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>

</div>
</div>
<a class="anchor" id="a2c4e8d00cb8d50e944323e373f145c97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfacejava_1_1util_1_1_collection.html">Collection</a>&lt;Thread&gt; java.util.concurrent.locks.ReentrantReadWriteLock.getQueuedWriterThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a collection containing threads that may be waiting to acquire the write lock. Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order. This method is designed to facilitate construction of subclasses that provide more extensive lock monitoring facilities.</p>
<dl class="section return"><dt>Returns</dt><dd>the collection of threads </dd></dl>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l01320">1320</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>

</div>
</div>
<a class="anchor" id="a5c757912c80d92c08ac853c1f5e6aba2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final int java.util.concurrent.locks.ReentrantReadWriteLock.getQueueLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an estimate of the number of threads waiting to acquire either the read or write lock. The value is only an estimate because the number of threads may change dynamically while this method traverses internal data structures. This method is designed for use in monitoring of the system state, not for synchronization control.</p>
<dl class="section return"><dt>Returns</dt><dd>the estimated number of threads waiting for this lock </dd></dl>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l01378">1378</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>

</div>
</div>
<a class="anchor" id="a1345e2584e0de498cd9f309f3c388fbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int java.util.concurrent.locks.ReentrantReadWriteLock.getReadHoldCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries the number of reentrant read holds on this lock by the current thread. A reader thread has a hold on a lock for each lock action that is not matched by an unlock action.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of holds on the read lock by the current thread, or zero if the read lock is not held by the current thread </dd></dl>
<dl class="section since"><dt>Since</dt><dd>1.6 </dd></dl>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l01305">1305</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a1345e2584e0de498cd9f309f3c388fbd_icgraph.png" border="0" usemap="#classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a1345e2584e0de498cd9f309f3c388fbd_icgraph" alt=""/></div>
<map name="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a1345e2584e0de498cd9f309f3c388fbd_icgraph" id="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a1345e2584e0de498cd9f309f3c388fbd_icgraph">
<area shape="rect" id="node2" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a6b0a965da93f54be0abd5693db560763" title="java.util.concurrent.locks.\lReentrantReadWriteLock.readLock" alt="" coords="332,5,556,47"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0ee7216cc9a7dc1a184c3fad51066a27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int java.util.concurrent.locks.ReentrantReadWriteLock.getReadLockCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries the number of read locks held for this lock. This method is designed for use in monitoring system state, not for synchronization control. </p><dl class="section return"><dt>Returns</dt><dd>the number of read locks held </dd></dl>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l01258">1258</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a0ee7216cc9a7dc1a184c3fad51066a27_icgraph.png" border="0" usemap="#classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a0ee7216cc9a7dc1a184c3fad51066a27_icgraph" alt=""/></div>
<map name="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a0ee7216cc9a7dc1a184c3fad51066a27_icgraph" id="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a0ee7216cc9a7dc1a184c3fad51066a27_icgraph">
<area shape="rect" id="node2" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a6b0a965da93f54be0abd5693db560763" title="java.util.concurrent.locks.\lReentrantReadWriteLock.readLock" alt="" coords="335,5,559,47"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="abfe04c040b9242b98847bb9954fc4c67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfacejava_1_1util_1_1_collection.html">Collection</a>&lt;Thread&gt; java.util.concurrent.locks.ReentrantReadWriteLock.getWaitingThreads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfacejava_1_1util_1_1concurrent_1_1locks_1_1_condition.html">Condition</a>&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a collection containing those threads that may be waiting on the given condition associated with the write lock. Because the actual set of threads may change dynamically while constructing this result, the returned collection is only a best-effort estimate. The elements of the returned collection are in no particular order. This method is designed to facilitate construction of subclasses that provide more extensive condition monitoring facilities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>the condition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the collection of threads </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalMonitorStateException</td><td>if this lock is not held </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the given condition is not associated with this lock </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the condition is null </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l01460">1460</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>

</div>
</div>
<a class="anchor" id="a2d6ea26f2bd360198a55318332e6449e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int java.util.concurrent.locks.ReentrantReadWriteLock.getWaitQueueLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfacejava_1_1util_1_1concurrent_1_1locks_1_1_condition.html">Condition</a>&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an estimate of the number of threads waiting on the given condition associated with the write lock. Note that because timeouts and interrupts may occur at any time, the estimate serves only as an upper bound on the actual number of waiters. This method is designed for use in monitoring of the system state, not for synchronization control.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>the condition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the estimated number of waiting threads </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalMonitorStateException</td><td>if this lock is not held </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the given condition is not associated with this lock </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the condition is null </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l01435">1435</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>

</div>
</div>
<a class="anchor" id="a8910fa648c0ea134e33590a7b1730d57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int java.util.concurrent.locks.ReentrantReadWriteLock.getWriteHoldCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries the number of reentrant write holds on this lock by the current thread. A writer thread has a hold on a lock for each lock action that is not matched by an unlock action.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of holds on the write lock by the current thread, or zero if the write lock is not held by the current thread </dd></dl>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l01292">1292</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a8910fa648c0ea134e33590a7b1730d57_icgraph.png" border="0" usemap="#classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a8910fa648c0ea134e33590a7b1730d57_icgraph" alt=""/></div>
<map name="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a8910fa648c0ea134e33590a7b1730d57_icgraph" id="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a8910fa648c0ea134e33590a7b1730d57_icgraph">
<area shape="rect" id="node2" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a6b0a965da93f54be0abd5693db560763" title="java.util.concurrent.locks.\lReentrantReadWriteLock.readLock" alt="" coords="273,13,497,54"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a1927fe8dc2fccedb9300ab16525b6b46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final boolean java.util.concurrent.locks.ReentrantReadWriteLock.hasQueuedThread </td>
          <td>(</td>
          <td class="paramtype">Thread&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries whether the given thread is waiting to acquire either the read or write lock. Note that because cancellations may occur at any time, a</p><div class="fragment"><div class="line"><span class="keyword">true</span> </div></div><!-- fragment --><p> return does not guarantee that this thread will ever acquire a lock. This method is designed primarily for use in monitoring of the system state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread</td><td>the thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><div class="fragment"><div class="line"><span class="keyword">true</span> </div></div><!-- fragment --> if the given thread is queued waiting for this lock </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullPointerException</td><td>if the thread is null </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l01364">1364</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>

</div>
</div>
<a class="anchor" id="a57eb2d2caca547ffa6e4a5fb61a19af7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final boolean java.util.concurrent.locks.ReentrantReadWriteLock.hasQueuedThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries whether any threads are waiting to acquire the read or write lock. Note that because cancellations may occur at any time, a</p><div class="fragment"><div class="line"><span class="keyword">true</span> </div></div><!-- fragment --><p> return does not guarantee that any other thread will ever acquire a lock. This method is designed primarily for use in monitoring of the system state.</p>
<dl class="section return"><dt>Returns</dt><dd><div class="fragment"><div class="line"><span class="keyword">true</span> </div></div><!-- fragment --> if there may be other threads waiting to acquire the lock </dd></dl>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l01349">1349</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>

</div>
</div>
<a class="anchor" id="a93166dce2b63dbf102c6787ea290e6a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean java.util.concurrent.locks.ReentrantReadWriteLock.hasWaiters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interfacejava_1_1util_1_1concurrent_1_1locks_1_1_condition.html">Condition</a>&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries whether any threads are waiting on the given condition associated with the write lock. Note that because timeouts and interrupts may occur at any time, a</p><div class="fragment"><div class="line"><span class="keyword">true</span> </div></div><!-- fragment --><p> return does not guarantee that a future</p><div class="fragment"><div class="line">signal </div></div><!-- fragment --><p> will awaken any threads. This method is designed primarily for use in monitoring of the system state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>the condition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><div class="fragment"><div class="line"><span class="keyword">true</span> </div></div><!-- fragment --> if there are any waiting threads </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalMonitorStateException</td><td>if this lock is not held </td></tr>
    <tr><td class="paramname">IllegalArgumentException</td><td>if the given condition is not associated with this lock </td></tr>
    <tr><td class="paramname">NullPointerException</td><td>if the condition is null </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l01412">1412</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>

</div>
</div>
<a class="anchor" id="aba945e3874c9a27122bfb9563bdd14ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final boolean java.util.concurrent.locks.ReentrantReadWriteLock.isFair </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns</p><div class="fragment"><div class="line"><span class="keyword">true</span> </div></div><!-- fragment --><p> if this lock has fairness set true.</p>
<dl class="section return"><dt>Returns</dt><dd><div class="fragment"><div class="line"><span class="keyword">true</span> </div></div><!-- fragment --> if this lock has fairness set true </dd></dl>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l01231">1231</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>

</div>
</div>
<a class="anchor" id="a36eeeab82a6e391efa778aa20b747b42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean java.util.concurrent.locks.ReentrantReadWriteLock.isWriteLocked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries if the write lock is held by any thread. This method is designed for use in monitoring system state, not for synchronization control.</p>
<dl class="section return"><dt>Returns</dt><dd><div class="fragment"><div class="line"><span class="keyword">true</span> </div></div><!-- fragment --> if any thread holds the write lock and <div class="fragment"><div class="line"><span class="keyword">false</span> </div></div><!-- fragment --> otherwise </dd></dl>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l01270">1270</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a36eeeab82a6e391efa778aa20b747b42_icgraph.png" border="0" usemap="#classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a36eeeab82a6e391efa778aa20b747b42_icgraph" alt=""/></div>
<map name="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a36eeeab82a6e391efa778aa20b747b42_icgraph" id="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a36eeeab82a6e391efa778aa20b747b42_icgraph">
<area shape="rect" id="node2" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a6b0a965da93f54be0abd5693db560763" title="java.util.concurrent.locks.\lReentrantReadWriteLock.readLock" alt="" coords="308,5,532,47"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a1e83e72a0eeca1519ff833c6b57d6b3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean java.util.concurrent.locks.ReentrantReadWriteLock.isWriteLockedByCurrentThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries if the write lock is held by the current thread.</p>
<dl class="section return"><dt>Returns</dt><dd><div class="fragment"><div class="line"><span class="keyword">true</span> </div></div><!-- fragment --> if the current thread holds the write lock and <div class="fragment"><div class="line"><span class="keyword">false</span> </div></div><!-- fragment --> otherwise </dd></dl>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l01280">1280</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>

</div>
</div>
<a class="anchor" id="a6b0a965da93f54be0abd5693db560763"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ReentrantReadWriteLock.ReadLock java.util.concurrent.locks.ReentrantReadWriteLock.readLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the lock used for reading.</p>
<dl class="section return"><dt>Returns</dt><dd>the lock used for reading </dd></dl>

<p>Implements <a class="el" href="interfacejava_1_1util_1_1concurrent_1_1locks_1_1_read_write_lock.html#a8c8c3ad1e77a492c17d916883be6d2ed">java.util.concurrent.locks.ReadWriteLock</a>.</p>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l00246">246</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a6b0a965da93f54be0abd5693db560763_cgraph.png" border="0" usemap="#classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a6b0a965da93f54be0abd5693db560763_cgraph" alt=""/></div>
<map name="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a6b0a965da93f54be0abd5693db560763_cgraph" id="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a6b0a965da93f54be0abd5693db560763_cgraph">
<area shape="rect" id="node2" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a8cc563c210e82fa8054b24e376127aca" title="java.util.concurrent.locks.\lReentrantReadWriteLock.getOwner" alt="" coords="305,5,531,47"/>
<area shape="rect" id="node3" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a0ee7216cc9a7dc1a184c3fad51066a27" title="java.util.concurrent.locks.\lReentrantReadWriteLock.getReadLockCount" alt="" coords="277,71,559,112"/>
<area shape="rect" id="node4" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a36eeeab82a6e391efa778aa20b747b42" title="java.util.concurrent.locks.\lReentrantReadWriteLock.isWriteLocked" alt="" coords="291,136,545,177"/>
<area shape="rect" id="node5" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a8910fa648c0ea134e33590a7b1730d57" title="java.util.concurrent.locks.\lReentrantReadWriteLock.getWrite\lHoldCount" alt="" coords="308,202,528,258"/>
<area shape="rect" id="node6" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a1345e2584e0de498cd9f309f3c388fbd" title="java.util.concurrent.locks.\lReentrantReadWriteLock.getReadHoldCount" alt="" coords="279,283,557,324"/>
<area shape="rect" id="node7" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a0456f201308ee5876f17c93447cc9639" title="java.util.concurrent.locks.\lReentrantReadWriteLock.toString" alt="" coords="310,348,526,389"/>
<area shape="rect" id="node8" href="classjava_1_1lang_1_1_class.html#a1e964eb07316a697a06d5ceb92a74533" title="java.lang.Class.getDeclared\lField" alt="" coords="607,348,789,389"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a0456f201308ee5876f17c93447cc9639"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String java.util.concurrent.locks.ReentrantReadWriteLock.toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a string identifying this lock, as well as its lock state. The state, in brackets, includes the String</p><div class="fragment"><div class="line"><span class="stringliteral">&quot;Write locks =&quot;</span> </div></div><!-- fragment --><p> followed by the number of reentrantly held write locks, and the String</p><div class="fragment"><div class="line"><span class="stringliteral">&quot;Read locks =&quot;</span> </div></div><!-- fragment --><p> followed by the number of held read locks.</p>
<dl class="section return"><dt>Returns</dt><dd>a string identifying this lock, as well as its lock state </dd></dl>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l01477">1477</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a0456f201308ee5876f17c93447cc9639_cgraph.png" border="0" usemap="#classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a0456f201308ee5876f17c93447cc9639_cgraph" alt=""/></div>
<map name="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a0456f201308ee5876f17c93447cc9639_cgraph" id="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a0456f201308ee5876f17c93447cc9639_cgraph">
<area shape="rect" id="node2" href="classjava_1_1lang_1_1_class.html#a1e964eb07316a697a06d5ceb92a74533" title="java.lang.Class.getDeclared\lField" alt="" coords="269,5,452,47"/>
</map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a0456f201308ee5876f17c93447cc9639_icgraph.png" border="0" usemap="#classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a0456f201308ee5876f17c93447cc9639_icgraph" alt=""/></div>
<map name="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a0456f201308ee5876f17c93447cc9639_icgraph" id="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock_a0456f201308ee5876f17c93447cc9639_icgraph">
<area shape="rect" id="node2" href="classjava_1_1util_1_1concurrent_1_1locks_1_1_reentrant_read_write_lock.html#a6b0a965da93f54be0abd5693db560763" title="java.util.concurrent.locks.\lReentrantReadWriteLock.readLock" alt="" coords="269,5,493,47"/>
</map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a85c19d8265947415fc44b364229445df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ReentrantReadWriteLock.WriteLock java.util.concurrent.locks.ReentrantReadWriteLock.writeLock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the lock used for writing.</p>
<dl class="section return"><dt>Returns</dt><dd>the lock used for writing </dd></dl>

<p>Implements <a class="el" href="interfacejava_1_1util_1_1concurrent_1_1locks_1_1_read_write_lock.html#aa3090a46b35efb2a9cfa8c22cc35a512">java.util.concurrent.locks.ReadWriteLock</a>.</p>

<p>Definition at line <a class="el" href="_reentrant_read_write_lock_8java_source.html#l00245">245</a> of file <a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>E:/00_Code/openjdk8/java/util/concurrent/locks/<a class="el" href="_reentrant_read_write_lock_8java_source.html">ReentrantReadWriteLock.java</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
