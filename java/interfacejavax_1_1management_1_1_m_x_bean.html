<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>openjdk8_analysis: javax.management.MXBean Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">openjdk8_analysis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacejavax.html">javax</a></li><li class="navelem"><a class="el" href="namespacejavax_1_1management.html">management</a></li><li class="navelem"><a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="interfacejavax_1_1management_1_1_m_x_bean-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">javax.management.MXBean Interface Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0b77e799efe09dbb3a5d8aefc160d139"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html#a0b77e799efe09dbb3a5d8aefc160d139">value</a> () default true</td></tr>
<tr class="separator:a0b77e799efe09dbb3a5d8aefc160d139"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Annotation to mark an interface explicitly as being an <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> interface, or as not being an <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> interface. By default, an interface is an <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> interface if it is public and its name ends with</p><div class="fragment"><div class="line">MXBean </div></div><!-- fragment --><p> , as in</p><div class="fragment"><div class="line">SomethingMXBean </div></div><!-- fragment --><p> . The following interfaces are <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> interfaces:</p>
<pre>
    public interface WhatsitMXBean {}</pre><pre>    &amp;#64;<a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a>
    public interface Whatsit1Interface {}</pre><pre>    &amp;#64;MXBean(true)
    public interface Whatsit2Interface {}
    </pre><p>The following interfaces are not <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> interfaces:</p>
<pre>
    interface NonPublicInterfaceNotMXBean{}</pre><pre>    public interface Whatsit3Interface{}</pre><pre>    &amp;#64;MXBean(false)
    public interface MisleadingMXBean {}
    </pre><h3 id="MXBean-spec"><a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> specification</h3>
<p>The <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> concept provides a simple way to code an MBean that only references a predefined set of types, the ones defined by <a class="el" href="namespacejavax_1_1management_1_1openmbean.html">javax.management.openmbean</a>. In this way, you can be sure that your MBean will be usable by any client, including remote clients, without any requirement that the client have access to <em>model-specific classes</em> representing the types of your MBeans.</p>
<p>The concepts are easier to understand by comparison with the Standard MBean concept. Here is how a managed object might be represented as a Standard MBean, and as an <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a>:</p>
<table  border="1" cellpadding="5" summary="Standard Bean vs. MXBean">
<tr>
<th>Standard MBean</th><th><a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a>  </th></tr>
<tr>
<td><pre>
public interface MemoryPool<b>MBean</b> {
    String getName();
    MemoryUsage getUsage();
...
}
          </pre> </td><td><pre>
public interface MemoryPool<b><a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a></b> {
    String getName();
    MemoryUsage getUsage();
...
}
          </pre>  </td></tr>
</table>
<p>As you can see, the definitions are very similar. The only difference is that the convention for naming the interface is to use <code><em>Something</em><a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a></code> for MXBeans, rather than <code><em>Something</em>MBean</code> for Standard MBeans.</p>
<p>In this managed object, there is an attribute called <code>Usage</code> of type <a class="el" href="">MemoryUsage</a>. The point of an attribute like this is that it gives a coherent snapshot of a set of data items. For example, it might include the current amount of used memory in the memory pool, and the current maximum of the memory pool. If these were separate items, obtained with separate <a class="el" href="interfacejavax_1_1management_1_1_m_bean_server.html#a4557e1342e88ef58b284747478cb257f">getAttribute</a> calls, then we could get values seen at different times that were not consistent. We might get a <code>used</code> value that was greater than the <code>max</code> value.</p>
<p>So, we might define <code>MemoryUsage</code> like this:</p>
<table  border="1" cellpadding="5" summary="Standard Bean vs. MXBean">
<tr>
<th>Standard MBean</th><th><a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a>  </th></tr>
<tr>
<td><pre>
public class MemoryUsage <b>implements Serializable</b> {
standard JavaBean conventions with getters</pre><pre>    public MemoryUsage(long init, long used,
                       long committed, long max) {...}
    long getInit() {...}
    long getUsed() {...}
    long getCommitted() {...}
    long getMax() {...}
}
          </pre> </td><td><pre>
public class MemoryUsage {
standard JavaBean conventions with getters
    <b>&amp;#64;ConstructorProperties({"init", "used", "committed", "max"})</b>
    public MemoryUsage(long init, long used,
                       long committed, long max) {...}
    long getInit() {...}
    long getUsed() {...}
    long getCommitted() {...}
    long getMax() {...}
}
          </pre>  </td></tr>
</table>
<p>The definitions are the same in the two cases, except that with the <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a>, <code>MemoryUsage</code> no longer needs to be marked <code>Serializable</code> (though it can be). On the other hand, we have added a</p><div class="fragment"><div class="line">@ConstructorProperties </div></div><!-- fragment --><p> annotation to link the constructor parameters to the corresponding getters. We will see more about this below.</p>
<p><code>MemoryUsage</code> is a <em>model-specific class</em>. With Standard MBeans, a client of the MBean Server cannot access the <code>Usage</code> attribute if it does not know the class <code>MemoryUsage</code>. Suppose the client is a generic console based on <a class="el" href="classjavax_1_1management_1_1_j_m_x.html">JMX</a> technology. Then the console would have to be configured with the model-specific classes of every application it might connect to. The problem is even worse for clients that are not written in the Java language. Then there may not be any way to tell the client what a <code>MemoryUsage</code> looks like.</p>
<p>This is where MXBeans differ from Standard MBeans. Although we define the management interface in almost exactly the same way, the <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> framework <em>converts</em> model-specific classes into standard classes from the Java platform. Using arrays and the <a class="el" href="interfacejavax_1_1management_1_1openmbean_1_1_composite_data.html">CompositeData</a> and <a class="el" href="interfacejavax_1_1management_1_1openmbean_1_1_tabular_data.html">TabularData</a> classes from the standard <a class="el" href="namespacejavax_1_1management_1_1openmbean.html">javax.management.openmbean</a> package, it is possible to build data structures of arbitrary complexity using only standard classes.</p>
<p>This becomes clearer if we compare what the clients of the two models might look like:</p>
<table  border="1" cellpadding="5" summary="Standard Bean vs. MXBean">
<tr>
<th>Standard MBean</th><th><a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a>  </th></tr>
<tr>
<td><pre>
String name = (String)
    mbeanServer.<a class="el" href="interfacejavax_1_1management_1_1_m_bean_server.html#a4557e1342e88ef58b284747478cb257f">
    getAttribute</a>(objectName, "Name");
<b>MemoryUsage</b> usage = (<b>MemoryUsage</b>)
    mbeanServer.getAttribute(objectName, "Usage");
<b>long used = usage.getUsed();</b>
          </pre> </td><td><pre>
String name = (String)
    mbeanServer.<a class="el" href="interfacejavax_1_1management_1_1_m_bean_server.html#a4557e1342e88ef58b284747478cb257f">
    getAttribute</a>(objectName, "Name");
<b><a class="el" href="">CompositeData</a></b> usage = (<b>CompositeData</b>)
    mbeanServer.getAttribute(objectName, "Usage");
<b>long used = (Long) usage.<a class="el" href="interfacejavax_1_1management_1_1openmbean_1_1_composite_data.html#a7ecea34fc3a31623f03ce9925d7e1ca4"> get</a>("used");</b>
          </pre> </td></tr>
</table>
<p>For attributes with simple types like <code>String</code>, the code is the same. But for attributes with complex types, the Standard MBean code requires the client to know the model-specific class <code>MemoryUsage</code>, while the <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> code requires no non-standard classes.</p>
<p>The client code shown here is slightly more complicated for the <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> client. But, if the client does in fact know the model, here the interface <code>MemoryPoolMXBean</code> and the class <code>MemoryUsage</code>, then it can construct a <em>proxy</em>. This is the recommended way to interact with managed objects when you know the model beforehand, regardless of whether you are using Standard MBeans or MXBeans:</p>
<table  border="1" cellpadding="5" summary="Standard Bean vs. MXBean">
<tr>
<th>Standard MBean</th><th><a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a>  </th></tr>
<tr>
<td><pre>
MemoryPool<b>MBean</b> proxy =
    <a class="el" href="classjavax_1_1management_1_1_j_m_x.html">JMX</a>.<b><a class="el" href=""> ObjectName,
              Class) newMBeanProxy</a></b>(
        mbeanServer,
        objectName,
        MemoryPool<b>MBean</b>.class);
String name = proxy.getName();
MemoryUsage usage = proxy.getUsage();
long used = usage.getUsed();
          </pre> </td><td><pre>
MemoryPool<b><a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a></b> proxy =
    <a class="el" href="classjavax_1_1management_1_1_j_m_x.html">JMX</a>.<b><a class="el" href=""> ObjectName,
              Class) newMXBeanProxy</a></b>(
        mbeanServer,
        objectName,
        MemoryPool<b><a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a></b>.class);
String name = proxy.getName();
MemoryUsage usage = proxy.getUsage();
long used = usage.getUsed();
          </pre>  </td></tr>
</table>
<p>Implementing the MemoryPool object works similarly for both Standard MBeans and MXBeans.</p>
<table  border="1" cellpadding="5" summary="Standard Bean vs. MXBean">
<tr>
<th>Standard MBean</th><th><a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a>  </th></tr>
<tr>
<td><pre>
public class MemoryPool
        implements MemoryPool<b>MBean</b> {
    public String getName() {...}
    public MemoryUsage getUsage() {...}
...
}
          </pre> </td><td><pre>
public class MemoryPool
        implements MemoryPool<b><a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a></b> {
    public String getName() {...}
    public MemoryUsage getUsage() {...}
...
}
          </pre>  </td></tr>
</table>
<p>Registering the MBean in the MBean Server works in the same way in both cases:</p>
<table  border="1" cellpadding="5" summary="Standard Bean vs. MXBean">
<tr>
<th>Standard MBean</th><th><a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a>  </th></tr>
<tr>
<td><pre>
{
    MemoryPool<b>MBean</b> pool = new MemoryPool();
    mbeanServer.<a class="el" href="interfacejavax_1_1management_1_1_m_bean_server.html#ac724f2fafe1fb8a1102a948cc577e15a">
    registerMBean</a>(pool, objectName);
}
          </pre> </td><td><pre>
{
    MemoryPool<b><a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a></b> pool = new MemoryPool();
    mbeanServer.<a class="el" href="interfacejavax_1_1management_1_1_m_bean_server.html#ac724f2fafe1fb8a1102a948cc577e15a">
    registerMBean</a>(pool, objectName);
}
          </pre>  </td></tr>
</table>
<pre class="fragment">&lt;h2 id="mxbean-def"&gt;Definition of an MXBean&lt;/h2&gt;

&lt;p&gt;An MXBean is a kind of MBean.  An MXBean object can be
  registered directly in the MBean Server, or it can be used as an
  argument to {@link StandardMBean} and the resultant MBean
  registered in the MBean Server.&lt;/p&gt;

&lt;p&gt;When an object is registered in the MBean Server using the
</pre> <div class="fragment"><div class="line">registerMBean </div></div><!-- fragment --><p> or</p><div class="fragment"><div class="line">createMBean </div></div><!-- fragment --><p> methods of the <a class="el" href="interfacejavax_1_1management_1_1_m_bean_server.html">MBeanServer</a> interface, the object's class is examined to determine what type of MBean it is:</p>
<ul>
<li>
<p class="startli">If the class implements the interface <a class="el" href="interfacejavax_1_1management_1_1_dynamic_m_bean.html">DynamicMBean</a> then the MBean is a Dynamic MBean. Note that the class </p><div class="fragment"><div class="line">StandardMBean </div></div><!-- fragment --><p> implements this interface, so this case applies to a Standard MBean or <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> created using the class</p><div class="fragment"><div class="line">StandardMBean </div></div><!-- fragment --><p> .</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Otherwise, if the class matches the Standard MBean naming conventions, then the MBean is a Standard MBean.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Otherwise, it may be an <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a>. The set of interfaces implemented by the object is examined for interfaces that:</p>
<ul>
<li>
have a class name <code><em>S</em><a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a></code> where <code><em>S</em></code> is any non-empty string, and do not have an annotation<div class="fragment"><div class="line">@MXBean(<span class="keyword">false</span>) </div></div><!-- fragment --> ; and/or </li>
<li>
have an annotation<div class="fragment"><div class="line">@MXBean(<span class="keyword">true</span>) </div></div><!-- fragment --> or just<div class="fragment"><div class="line">@MXBean </div></div><!-- fragment --> . </li>
</ul>
<p>If there is exactly one such interface, or if there is one such interface that is a subinterface of all the others, then the object is an <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a>. The interface in question is the <em><a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> interface</em>. In the example above, the <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> interface is</p><div class="fragment"><div class="line">MemoryPoolMXBean </div></div><!-- fragment --><p> .</p>
<p class="endli"></p>
</li>
<li>
If none of these conditions is met, the MBean is invalid and the attempt to register it will generate <a class="el" href="classjavax_1_1management_1_1_not_compliant_m_bean_exception.html">NotCompliantMBeanException</a>. </li>
</ul>
<p>Every Java type that appears as the parameter or return type of a method in an <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> interface must be <em>convertible</em> using the rules below. Additionally, parameters must be <em>reconstructible</em> as defined below.</p>
<p>An attempt to construct an <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> that does not conform to the above rules will produce an exception.</p>
<pre class="fragment">&lt;h2 id="naming-conv"&gt;Naming conventions&lt;/h2&gt;

&lt;p&gt;The same naming conventions are applied to the methods in an
  MXBean as in a Standard MBean:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A method &lt;code&gt;&lt;em&gt;T&lt;/em&gt; get&lt;em&gt;N&lt;/em&gt;()&lt;/code&gt;, where
    &lt;code&gt;&lt;em&gt;T&lt;/em&gt;&lt;/code&gt; is a Java type (not &lt;code&gt;void&lt;/code&gt;)
    and &lt;code&gt;&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; is a non-empty string, specifies
    that there is a readable attribute called
    &lt;code&gt;&lt;em&gt;N&lt;/em&gt;&lt;/code&gt;.  The Java type and Open type of the
    attribute are determined by the mapping rules below.
    The method@code final Class getClass() @endcode  inherited from@code 
    Object @endcode  is ignored when looking for getters.&lt;/li&gt;

  &lt;li&gt;A method &lt;code&gt;boolean is&lt;em&gt;N&lt;/em&gt;()&lt;/code&gt; specifies that
    there is a readable attribute called &lt;code&gt;&lt;em&gt;N&lt;/em&gt;&lt;/code&gt;
    with Java type &lt;code&gt;boolean&lt;/code&gt; and Open type
    &lt;code&gt;SimpleType.Boolean&lt;/code&gt;.&lt;/li&gt;

  &lt;li&gt;A method &lt;code&gt;void set&lt;em&gt;N&lt;/em&gt;(&lt;em&gt;T&lt;/em&gt; x)&lt;/code&gt;
    specifies that there is a writeable attribute called
    &lt;code&gt;&lt;em&gt;N&lt;/em&gt;&lt;/code&gt;.  The Java type and Open type of the
    attribute are determined by the mapping rules below.  (Of
    course, the name &lt;code&gt;x&lt;/code&gt; of the parameter is
    irrelevant.)&lt;/li&gt;

  &lt;li&gt;Every other method specifies that there is an operation with
    the same name as the method.  The Java type and Open type of the
    return value and of each parameter are determined by the mapping
    rules below.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The rules for &lt;code&gt;get&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; and
  &lt;code&gt;is&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; collectively define the notion of a
  &lt;em&gt;getter&lt;/em&gt;.  The rule for &lt;code&gt;set&lt;em&gt;N&lt;/em&gt;&lt;/code&gt; defines
  the notion of a &lt;em&gt;setter&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;It is an error for there to be two getters with the same name, or
  two setters with the same name.  If there is a getter and a setter
  for the same name, then the type &lt;code&gt;&lt;em&gt;T&lt;/em&gt;&lt;/code&gt; in both
  must be the same.  In this case the attribute is read/write.  If
  there is only a getter or only a setter, the attribute is
  read-only or write-only respectively.&lt;/p&gt;


&lt;h2 id="mapping-rules"&gt;Type mapping rules&lt;/h2&gt;

&lt;p&gt;An MXBean is a kind of Open MBean, as defined by the {@link
  javax.management.openmbean} package.  This means that the types of
  attributes, operation parameters, and operation return values must
  all be describable using &lt;em&gt;Open Types&lt;/em&gt;, that is the four
  standard subclasses of {@link javax.management.openmbean.OpenType}.
  MXBeans achieve this by mapping Java types into Open Types.&lt;/p&gt;

&lt;p&gt;For every Java type &lt;em&gt;J&lt;/em&gt;, the MXBean mapping is described
  by the following information:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The corresponding Open Type, &lt;em&gt;opentype(J)&lt;/em&gt;.  This is
    an instance of a subclass of {@link
    javax.management.openmbean.OpenType}.&lt;/li&gt;
  &lt;li&gt;The &lt;em&gt;mapped&lt;/em&gt; Java type, &lt;em&gt;opendata(J)&lt;/em&gt;, which is
    always the same for any given &lt;em&gt;opentype(J)&lt;/em&gt;.  This is a Java
    class.&lt;/li&gt;
  &lt;li&gt;How a value is converted from type &lt;em&gt;J&lt;/em&gt; to type
    &lt;em&gt;opendata(J)&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;How a value is converted from type &lt;em&gt;opendata(J)&lt;/em&gt; to
    type &lt;em&gt;J&lt;/em&gt;, if it can be.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For example, for the Java type@code List&lt;String&gt; @endcode :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The Open Type, &lt;em&gt;opentype(&lt;/em&gt;@code 
    List&lt;String&gt; @endcode &lt;em&gt;)&lt;/em&gt;, is {@link ArrayType}&lt;code&gt;(1, &lt;/code&gt;{@link
      SimpleType#STRING}&lt;code&gt;)&lt;/code&gt;, representing a 1-dimensional
      array of &lt;code&gt;String&lt;/code&gt;s.&lt;/li&gt;
  &lt;li&gt;The mapped Java type, &lt;em&gt;opendata(&lt;/em&gt;@code 
    List&lt;String&gt; @endcode &lt;em&gt;)&lt;/em&gt;, is@code String[] @endcode .&lt;/li&gt;
  &lt;li&gt;A@code List&lt;String&gt; @endcode  can be converted to a@code String[] @endcode 
      using {@link List#toArray(Object[]) List.toArray(new
      String[0])}.&lt;/li&gt;
  &lt;li&gt;A@code String[] @endcode  can be converted to a@code List&lt;String&gt; @endcode 
      using {@link Arrays#asList Arrays.asList}.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If no mapping rules exist to derive &lt;em&gt;opentype(J)&lt;/em&gt; from
  &lt;em&gt;J&lt;/em&gt;, then &lt;em&gt;J&lt;/em&gt; cannot be the type of a method
  parameter or return value in an MXBean interface.&lt;/p&gt;

&lt;p id="reconstructible-def"&gt;If there is a way to convert
  &lt;em&gt;opendata(J)&lt;/em&gt; back to &lt;em&gt;J&lt;/em&gt; then we say that &lt;em&gt;J&lt;/em&gt; is
  &lt;em&gt;reconstructible&lt;/em&gt;.  All method parameters in an MXBean
  interface must be reconstructible, because when the MXBean
  framework is invoking a method it will need to convert those
  parameters from &lt;em&gt;opendata(J)&lt;/em&gt; to &lt;em&gt;J&lt;/em&gt;.  In a proxy
  generated by {@link JMX#newMXBeanProxy(MBeanServerConnection,
  ObjectName, Class) JMX.newMXBeanProxy}, it is the return values
  of the methods in the MXBean interface that must be
  reconstructible.&lt;/p&gt;

&lt;p&gt;Null values are allowed for all Java types and Open Types,
  except primitive Java types where they are not possible.  When
  converting from type &lt;em&gt;J&lt;/em&gt; to type &lt;em&gt;opendata(J)&lt;/em&gt; or
  from type &lt;em&gt;opendata(J)&lt;/em&gt; to type &lt;em&gt;J&lt;/em&gt;, a null value is
  mapped to a null value.&lt;/p&gt;

&lt;p&gt;The following table summarizes the type mapping rules.&lt;/p&gt;

&lt;table border="1" cellpadding="5" summary="Type Mapping Rules"&gt;
  &lt;tr&gt;
    &lt;th&gt;Java type &lt;em&gt;J&lt;/em&gt;&lt;/th&gt;
    &lt;th&gt;&lt;em&gt;opentype(J)&lt;/em&gt;&lt;/th&gt;
    &lt;th&gt;&lt;em&gt;opendata(J)&lt;/em&gt;&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tbody valign="top"&gt;
    &lt;tr&gt;
      &lt;td&gt;@code int @endcode ,@code boolean @endcode , etc&lt;br&gt;
        (the 8 primitive Java types)&lt;/td&gt;
      &lt;td&gt;@code SimpleType.INTEGER @endcode ,&lt;br&gt;
</pre> <div class="fragment"><div class="line">SimpleType.BOOLEAN </div></div><!-- fragment --><p> , etc </p>
<div class="fragment"><div class="line">Integer </div></div><!-- fragment --><p> ,</p><div class="fragment"><div class="line">Boolean </div></div><!-- fragment --><p> , etc<br />
 (the corresponding boxed types)  </p>
<div class="fragment"><div class="line">Integer </div></div><!-- fragment --><p> ,</p><div class="fragment"><div class="line">ObjectName </div></div><!-- fragment --><p> , etc<br />
 (the types covered by <a class="el" href="">SimpleType</a>) </p>
<p>the corresponding</p><div class="fragment"><div class="line">SimpleType </div></div><!-- fragment -->  <p><em>J</em>, the same type  </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span>[] </div></div><!-- fragment --><p> etc<br />
 (a one-dimensional array with<br />
 primitive element type) </p>
<div class="fragment"><div class="line">ArrayType.getPrimitiveArrayType(<span class="keywordtype">int</span>[].<span class="keyword">class</span>) </div></div><!-- fragment --><p> etc </p>
<p><em>J</em>, the same type </p>
<p><em>E</em></p><div class="fragment"><div class="line">[] </div></div><!-- fragment --><p> <br />
 (an array with non-primitive element type <em>E</em>; this includes</p><div class="fragment"><div class="line"><span class="keywordtype">int</span>[][] </div></div><!-- fragment --><p> , where <em>E</em> is</p><div class="fragment"><div class="line"><span class="keywordtype">int</span>[] </div></div><!-- fragment --><p> ) </p>
<div class="fragment"><div class="line">ArrayType.getArrayType( </div></div><!-- fragment --><p> <em>opentype(E)</em></p><div class="fragment"><div class="line">) </div></div><!-- fragment -->  <p><em>opendata(E)</em></p><div class="fragment"><div class="line">[] </div></div><!-- fragment -->   <div class="fragment"><div class="line">List&lt;</div></div><!-- fragment --><p> <em>E</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment --><p> <br />
 </p><div class="fragment"><div class="line">Set&lt;</div></div><!-- fragment --><p> <em>E</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment --><p> <br />
 </p><div class="fragment"><div class="line">SortedSet&lt;</div></div><!-- fragment --><p> <em>E</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment --><p> (see below) </p>
<p>same as for <em>E</em></p><div class="fragment"><div class="line">[] </div></div><!-- fragment -->  <p>same as for <em>E</em></p><div class="fragment"><div class="line">[] </div></div><!-- fragment -->   <p>An enumeration <em>E</em><br />
 (declared in Java as</p><div class="fragment"><div class="line"><span class="keyword">enum</span>  </div></div><!-- fragment --><p> <em>E</em> </p><div class="fragment"><div class="line">{...} </div></div><!-- fragment --><p> ) </p>
<div class="fragment"><div class="line">SimpleType.STRING </div></div><!-- fragment -->  <div class="fragment"><div class="line">String </div></div><!-- fragment -->   <div class="fragment"><div class="line">Map&lt;</div></div><!-- fragment --><p> <em>K</em>,<em>V</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment --><p> <br />
 </p><div class="fragment"><div class="line">SortedMap&lt;</div></div><!-- fragment --><p> <em>K</em>,<em>V</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment -->  <p><a class="el" href="">TabularType</a><br />
 (see below) </p>
<p><a class="el" href="">TabularData</a><br />
 (see below)  </p>
<p>An <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> interface </p>
<div class="fragment"><div class="line">SimpleType.OBJECTNAME </div></div><!-- fragment --><p> <br />
 (see below) </p>
<p><a class="el" href="classjavax_1_1management_1_1_object_name.html">ObjectName</a><br />
 (see below)  </p>
<p>Any other type </p>
<p><a class="el" href="">CompositeType</a>, if possible<br />
 (see below) </p>
<p><a class="el" href="">CompositeData</a> &lt;/tbody&gt; </p>
<p>The following sections give further details of these rules.</p>
<pre class="fragment">&lt;h3&gt;Mappings for primitive types&lt;/h3&gt;

&lt;p&gt;The 8 primitive Java types
  (@code boolean @endcode ,@code byte @endcode ,@code short @endcode ,@code int @endcode ,@code 
  long @endcode ,@code float @endcode ,@code double @endcode ,@code char @endcode ) are mapped to the
  corresponding boxed types from@code java.lang @endcode , namely@code 
  Boolean @endcode ,@code Byte @endcode , etc.  The Open Type is the corresponding
</pre> <div class="fragment"><div class="line">SimpleType </div></div><!-- fragment --><p> . Thus, <em>opentype(</em></p><div class="fragment"><div class="line"><span class="keywordtype">long</span> </div></div><!-- fragment --><p> <em>)</em> is</p><div class="fragment"><div class="line">SimpleType.LONG </div></div><!-- fragment --><p> , and <em>opendata(</em></p><div class="fragment"><div class="line"><span class="keywordtype">long</span> </div></div><!-- fragment --><p> <em>)</em> is</p><div class="fragment"><div class="line"><a class="code" href="namespacejava.html">java</a>.<a class="code" href="namespacejava_1_1lang.html">lang</a>.<a class="code" href="classjava_1_1lang_1_1_long.html">Long</a> </div></div><!-- fragment --><p> .</p>
<p>An array of primitive type such as</p><div class="fragment"><div class="line"><span class="keywordtype">long</span>[] </div></div><!-- fragment --><p> can be represented directly as an Open Type. Thus, <em>openType(</em></p><div class="fragment"><div class="line"><span class="keywordtype">long</span>[] </div></div><!-- fragment --><p> <em>)</em> is</p><div class="fragment"><div class="line">ArrayType.getPrimitiveArrayType(<span class="keywordtype">long</span>[].<span class="keyword">class</span>) </div></div><!-- fragment --><p> , and <em>opendata(</em></p><div class="fragment"><div class="line"><span class="keywordtype">long</span>[] </div></div><!-- fragment --><p> <em>)</em> is</p><div class="fragment"><div class="line"><span class="keywordtype">long</span>[] </div></div><!-- fragment --><p> .</p>
<p>In practice, the difference between a plain</p><div class="fragment"><div class="line"><span class="keywordtype">int</span> </div></div><!-- fragment --><p> and</p><div class="fragment"><div class="line">Integer </div></div><!-- fragment --><p> , etc, does not show up because operations in the <a class="el" href="classjavax_1_1management_1_1_j_m_x.html">JMX</a> API are always on Java objects, not primitives. However, the difference <em>does</em> show up with arrays.</p>
<h3>Mappings for collections ( List&lt;  <em>E</em> &gt;  etc)</h3>
<p>A</p><div class="fragment"><div class="line">List&lt;</div></div><!-- fragment --><p> <em>E</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment --><p> or</p><div class="fragment"><div class="line">Set&lt;</div></div><!-- fragment --><p> <em>E</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment --><p> , such as</p><div class="fragment"><div class="line">List&lt;String&gt; </div></div><!-- fragment --><p> or</p><div class="fragment"><div class="line">Set&lt;ObjectName&gt; </div></div><!-- fragment --><p> , is mapped in the same way as an array of the same element type, such as</p><div class="fragment"><div class="line">String[] </div></div><!-- fragment --><p> or</p><div class="fragment"><div class="line">ObjectName[] </div></div><!-- fragment --><p> .</p>
<p>A</p><div class="fragment"><div class="line">SortedSet&lt;</div></div><!-- fragment --><p> <em>E</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment --><p> is also mapped in the same way as an <em>E</em></p><div class="fragment"><div class="line">[] </div></div><!-- fragment --><p> , but it is only convertible if <em>E</em> is a class or interface that implements <a class="el" href="interfacejava_1_1lang_1_1_comparable.html">java.lang.Comparable</a>. Thus, a</p><div class="fragment"><div class="line">SortedSet&lt;String&gt; </div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line">SortedSet&lt;Integer&gt; </div></div><!-- fragment --><p> is convertible, but a</p><div class="fragment"><div class="line">SortedSet&lt;int[]&gt; </div></div><!-- fragment --><p> or</p><div class="fragment"><div class="line">SortedSet&lt;List&lt;String&gt;&gt; </div></div><!-- fragment --><p> is not. The conversion of a</p><div class="fragment"><div class="line">SortedSet </div></div><!-- fragment --><p> instance will fail with an </p><div class="fragment"><div class="line">IllegalArgumentException </div></div><!-- fragment --><p> if it has a non-null <a class="el" href="interfacejava_1_1util_1_1_sorted_set.html#a0d5d2b11b70cfc87d69e3889fdb3f690">comparator()</a>.</p>
<p>A</p><div class="fragment"><div class="line">List&lt;</div></div><!-- fragment --><p> <em>E</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment --><p> is reconstructed as a </p><div class="fragment"><div class="line"><a class="code" href="namespacejava.html">java</a>.<a class="code" href="namespacejava_1_1util.html">util</a>.<a class="code" href="classjava_1_1util_1_1_array_list.html">ArrayList</a>&lt;</div></div><!-- fragment --><p> <em>E</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment --><p> ; a</p><div class="fragment"><div class="line">Set&lt;</div></div><!-- fragment --><p> <em>E</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment --><p> as a </p><div class="fragment"><div class="line"><a class="code" href="namespacejava.html">java</a>.<a class="code" href="namespacejava_1_1util.html">util</a>.<a class="code" href="classjava_1_1util_1_1_hash_set.html">HashSet</a>&lt;</div></div><!-- fragment --><p> <em>E</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment --><p> ; a</p><div class="fragment"><div class="line">SortedSet&lt;</div></div><!-- fragment --><p> <em>E</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment --><p> as a </p><div class="fragment"><div class="line"><a class="code" href="namespacejava.html">java</a>.<a class="code" href="namespacejava_1_1util.html">util</a>.<a class="code" href="classjava_1_1util_1_1_tree_set.html">TreeSet</a>&lt;</div></div><!-- fragment --><p> <em>E</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment --><p> .</p>
<h3>Mappings for maps ( Map&lt;  <em>K</em>,<em>V</em> &gt;  etc)</h3>
<p>A</p><div class="fragment"><div class="line">Map&lt;</div></div><!-- fragment --><p> <em>K</em>,<em>V</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment --><p> or</p><div class="fragment"><div class="line">SortedMap&lt;</div></div><!-- fragment --><p> <em>K</em>,<em>V</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment --><p> , for example</p><div class="fragment"><div class="line">Map&lt;String,ObjectName&gt; </div></div><!-- fragment --><p> , has Open Type <a class="el" href="">TabularType</a> and is mapped to a <a class="el" href="">TabularData</a>. The</p><div class="fragment"><div class="line">TabularType </div></div><!-- fragment --><p> has two items called</p><div class="fragment"><div class="line">key </div></div><!-- fragment --><p> and </p><div class="fragment"><div class="line"><a class="code" href="interfacejavax_1_1management_1_1_m_x_bean.html#a0b77e799efe09dbb3a5d8aefc160d139">value</a> </div></div><!-- fragment --><p> . The Open Type of</p><div class="fragment"><div class="line">key </div></div><!-- fragment --><p> is <em>opentype(K)</em>, and the Open Type of</p><div class="fragment"><div class="line"><a class="code" href="interfacejavax_1_1management_1_1_m_x_bean.html#a0b77e799efe09dbb3a5d8aefc160d139">value</a> </div></div><!-- fragment --><p> is <em>opentype(V)</em>. The index of the</p><div class="fragment"><div class="line">TabularType </div></div><!-- fragment --><p> is the single item</p><div class="fragment"><div class="line">key </div></div><!-- fragment --><p> .</p>
<p>For example, the</p><div class="fragment"><div class="line">TabularType </div></div><!-- fragment --><p> for a</p><div class="fragment"><div class="line">Map&lt;String,ObjectName&gt; </div></div><!-- fragment --><p> might be constructed with code like this:</p>
<pre>
String typeName =
    "java.util.Map&amp;lt;java.lang.String, javax.management.ObjectName&amp;gt;";
String[] keyValue =
    new String[] {"key", "value"};
OpenType[] openTypes =
    new OpenType[] {<a class="el" href="classjavax_1_1management_1_1openmbean_1_1_simple_type.html#a85efef9090948a4a9da6474ba01ccf93">SimpleType.STRING</a>, <a class="el" href="classjavax_1_1management_1_1openmbean_1_1_simple_type.html#ad2dbca022740688c5a6957ec2be67599">SimpleType.OBJECTNAME</a>};
CompositeType rowType =
    new CompositeType(typeName, typeName, keyValue, keyValue, openTypes);
TabularType tabularType =
    new TabularType(typeName, typeName, rowType, new String[] {"key"});
    </pre><p>The</p><div class="fragment"><div class="line">typeName </div></div><!-- fragment --><p> here is determined by the <a href="#type-names">type name rules</a> detailed below.</p>
<p>A</p><div class="fragment"><div class="line">SortedMap&lt;</div></div><!-- fragment --><p> <em>K</em>,<em>V</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment --><p> is mapped in the same way, but it is only convertible if <em>K</em> is a class or interface that implements <a class="el" href="interfacejava_1_1lang_1_1_comparable.html">java.lang.Comparable</a>. Thus, a</p><div class="fragment"><div class="line">SortedMap&lt;String,int[]&gt; </div></div><!-- fragment --><p> is convertible, but a </p><div class="fragment"><div class="line">SortedMap&lt;int[],String&gt; </div></div><!-- fragment --><p> is not. The conversion of a </p><div class="fragment"><div class="line">SortedMap </div></div><!-- fragment --><p> instance will fail with an</p><div class="fragment"><div class="line">IllegalArgumentException </div></div><!-- fragment --><p> if it has a non-null <a class="el" href="interfacejava_1_1util_1_1_sorted_map.html#a8bbb2514a76fd66db869350ceedc9a7a">comparator()</a>.</p>
<p>A</p><div class="fragment"><div class="line">Map&lt;</div></div><!-- fragment --><p> <em>K</em>,<em>V</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment --><p> is reconstructed as a</p><div class="fragment"><div class="line"><a class="code" href="namespacejava.html">java</a>.<a class="code" href="namespacejava_1_1util.html">util</a>.<a class="code" href="classjava_1_1util_1_1_hash_map.html">HashMap</a>&lt;</div></div><!-- fragment --><p> <em>K</em>,<em>V</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment --><p> ; a</p><div class="fragment"><div class="line">SortedMap&lt;</div></div><!-- fragment --><p> <em>K</em>,<em>V</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment --><p> as a</p><div class="fragment"><div class="line"><a class="code" href="namespacejava.html">java</a>.<a class="code" href="namespacejava_1_1util.html">util</a>.<a class="code" href="classjava_1_1util_1_1_tree_map.html">TreeMap</a>&lt;</div></div><!-- fragment --><p> <em>K</em>,<em>V</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment --><p> .</p>
<div class="fragment"><div class="line">TabularData </div></div><!-- fragment --><p> is an interface. The concrete class that is used to represent a</p><div class="fragment"><div class="line">Map&lt;</div></div><!-- fragment --><p> <em>K</em>,<em>V</em></p><div class="fragment"><div class="line">&gt; </div></div><!-- fragment --><p> as Open Data is <a class="el" href="">TabularDataSupport</a>, or another class implementing</p><div class="fragment"><div class="line">TabularData </div></div><!-- fragment --><p> that serializes as</p><div class="fragment"><div class="line">TabularDataSupport </div></div><!-- fragment --><p> .</p>
<pre class="fragment">&lt;h3 id="mxbean-map"&gt;Mappings for MXBean interfaces&lt;/h3&gt;

&lt;p&gt;An MXBean interface, or a type referenced within an MXBean
  interface, can reference another MXBean interface, &lt;em&gt;J&lt;/em&gt;.
  Then &lt;em&gt;opentype(J)&lt;/em&gt; is@code SimpleType.OBJECTNAME @endcode  and
  &lt;em&gt;opendata(J)&lt;/em&gt; is@code ObjectName @endcode .&lt;/p&gt;

&lt;p&gt;For example, suppose you have two MXBean interfaces like this:&lt;/p&gt;

&lt;pre&gt;
</pre><p> public interface ProductMXBean { public ModuleMXBean[] getModules(); }</p>
<p>public interface ModuleMXBean { public ProductMXBean getProduct(); } </p>
<p>The object implementing the</p><div class="fragment"><div class="line">ModuleMXBean </div></div><!-- fragment --><p> interface returns from its</p><div class="fragment"><div class="line">getProduct </div></div><!-- fragment --><p> method an object implementing the</p><div class="fragment"><div class="line">ProductMXBean </div></div><!-- fragment --><p> interface. The </p><div class="fragment"><div class="line">ModuleMXBean </div></div><!-- fragment --><p> object and the returned</p><div class="fragment"><div class="line">ProductMXBean </div></div><!-- fragment --><p> objects must both be registered as MXBeans in the same MBean Server.</p>
<p>The method</p><div class="fragment"><div class="line">ModuleMXBean.getProduct() </div></div><!-- fragment --><p> defines an attribute called</p><div class="fragment"><div class="line">Product </div></div><!-- fragment --><p> . The Open Type for this attribute is</p><div class="fragment"><div class="line">SimpleType.OBJECTNAME </div></div><!-- fragment --><p> , and the corresponding </p><div class="fragment"><div class="line">ObjectName </div></div><!-- fragment --><p> value will be the name under which the referenced</p><div class="fragment"><div class="line">ProductMXBean </div></div><!-- fragment --><p> is registered in the MBean Server.</p>
<p>If you make an <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> proxy for a</p><div class="fragment"><div class="line">ModuleMXBean </div></div><!-- fragment --><p> and call its</p><div class="fragment"><div class="line">getProduct() </div></div><!-- fragment --><p> method, the proxy will map the </p><div class="fragment"><div class="line">ObjectName </div></div><!-- fragment --><p> back into a</p><div class="fragment"><div class="line">ProductMXBean </div></div><!-- fragment --><p> by making another <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> proxy. More formally, when a proxy made with <a class="el" href="">ObjectName, Class) JMX.newMXBeanProxy(mbeanServerConnection, objectNameX, interfaceX)</a> needs to map</p><div class="fragment"><div class="line">objectNameY </div></div><!-- fragment --><p> back into</p><div class="fragment"><div class="line">interfaceY </div></div><!-- fragment --><p> , another <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> interface, it does so with</p><div class="fragment"><div class="line">JMX.newMXBeanProxy(mbeanServerConnection, objectNameY,</div><div class="line">interfaceY) </div></div><!-- fragment --><p> . The implementation may return a proxy that was previously created by a call to</p><div class="fragment"><div class="line">JMX.newMXBeanProxy </div></div><!-- fragment --><p> with the same parameters, or it may create a new proxy.</p>
<p>The reverse mapping is illustrated by the following change to the </p><div class="fragment"><div class="line">ModuleMXBean </div></div><!-- fragment --><p> interface:</p>
<pre>
public interface ModuleMXBean {
    public ProductMXBean getProduct();
    public void setProduct(ProductMXBean c);
}
    </pre><p>The presence of the</p><div class="fragment"><div class="line">setProduct </div></div><!-- fragment --><p> method now means that the </p><div class="fragment"><div class="line">Product </div></div><!-- fragment --><p> attribute is read/write. As before, the value of this attribute is an</p><div class="fragment"><div class="line">ObjectName </div></div><!-- fragment --><p> . When the attribute is set, the</p><div class="fragment"><div class="line">ObjectName </div></div><!-- fragment --><p> must be converted into the </p><div class="fragment"><div class="line">ProductMXBean </div></div><!-- fragment --><p> object that the</p><div class="fragment"><div class="line">setProduct </div></div><!-- fragment --><p> method expects. This object will be an <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> proxy for the given </p><div class="fragment"><div class="line">ObjectName </div></div><!-- fragment --><p> in the same MBean Server.</p>
<p>If you make an <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> proxy for a</p><div class="fragment"><div class="line">ModuleMXBean </div></div><!-- fragment --><p> and call its</p><div class="fragment"><div class="line">setProduct </div></div><!-- fragment --><p> method, the proxy will map its </p><div class="fragment"><div class="line">ProductMXBean </div></div><!-- fragment --><p> argument back into an</p><div class="fragment"><div class="line">ObjectName </div></div><!-- fragment --><p> . This will only work if the argument is in fact another proxy, for a</p><div class="fragment"><div class="line">ProductMXBean </div></div><!-- fragment --><p> in the same</p><div class="fragment"><div class="line">MBeanServerConnection </div></div><!-- fragment --><p> . The proxy can have been returned from another proxy (like</p><div class="fragment"><div class="line">ModuleMXBean.getProduct() </div></div><!-- fragment --><p> which returns a proxy for a</p><div class="fragment"><div class="line">ProductMXBean </div></div><!-- fragment --><p> ); or it can have been created by <a class="el" href="">JMX.newMXBeanProxy</a>; or it can have been created using <a class="el" href="classjava_1_1lang_1_1reflect_1_1_proxy.html">Proxy</a> with an invocation handler that is <a class="el" href="classjavax_1_1management_1_1_m_bean_server_invocation_handler.html">MBeanServerInvocationHandler</a> or a subclass.</p>
<p>If the same <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> were registered under two different </p><div class="fragment"><div class="line">ObjectName </div></div><!-- fragment --><p> s, a reference to that <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> from another <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> would be ambiguous. Therefore, if an <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> object is already registered in an MBean Server and an attempt is made to register it in the same MBean Server under another name, the result is an <a class="el" href="classjavax_1_1management_1_1_instance_already_exists_exception.html">InstanceAlreadyExistsException</a>. Registering the same MBean object under more than one name is discouraged in general, notably because it does not work well for MBeans that are <a class="el" href="interfacejavax_1_1management_1_1_notification_broadcaster.html">NotificationBroadcaster</a>s.</p>
<h3 id="composite-map">Mappings for other types</h3>
<p>Given a Java class or interface <em>J</em> that does not match the other rules in the table above, the <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> framework will attempt to map it to a <a class="el" href="">CompositeType</a> as follows. The type name of this </p><div class="fragment"><div class="line">CompositeType </div></div><!-- fragment --><p> is determined by the <a href="#type-names">type name rules</a> below.</p>
<p>The class is examined for getters using the conventions <a href="#naming-conv">above</a>. (Getters must be public instance methods.) If there are no getters, or if any getter has a type that is not convertible, then <em>J</em> is not convertible.</p>
<p>If there is at least one getter and every getter has a convertible type, then <em>opentype(J)</em> is a</p><div class="fragment"><div class="line">CompositeType </div></div><!-- fragment --><p> with one item for every getter. If the getter is</p>
<blockquote class="doxtable">
<p><code><em>T</em> get<em>Name</em>()</code> </p>
</blockquote>
<p>then the item in the</p><div class="fragment"><div class="line">CompositeType </div></div><!-- fragment --><p> is called</p><div class="fragment"><div class="line">name </div></div><!-- fragment --><p> and has type <em>opentype(T)</em>. For example, if the item is</p>
<blockquote class="doxtable">
<p><code>String getOwner()</code> </p>
</blockquote>
<p>then the item is called</p><div class="fragment"><div class="line">owner </div></div><!-- fragment --><p> and has Open Type</p><div class="fragment"><div class="line">SimpleType.STRING </div></div><!-- fragment --><p> . If the getter is</p>
<blockquote class="doxtable">
<p><code>boolean is<em>Name</em>()</code> </p>
</blockquote>
<p>then the item in the</p><div class="fragment"><div class="line">CompositeType </div></div><!-- fragment --><p> is called</p><div class="fragment"><div class="line">name </div></div><!-- fragment --><p> and has type</p><div class="fragment"><div class="line">SimpleType.BOOLEAN </div></div><!-- fragment --><p> .</p>
<p>Notice that the first character (or code point) is converted to lower case. This follows the Java Beans convention, which for historical reasons is different from the Standard MBean convention. In a Standard MBean or <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> interface, a method </p><div class="fragment"><div class="line">getOwner </div></div><!-- fragment --><p> defines an attribute called</p><div class="fragment"><div class="line">Owner </div></div><!-- fragment --><p> , while in a Java Bean or mapped</p><div class="fragment"><div class="line">CompositeType </div></div><!-- fragment --><p> , a method</p><div class="fragment"><div class="line">getOwner </div></div><!-- fragment --><p> defines a property or item called</p><div class="fragment"><div class="line">owner </div></div><!-- fragment --><p> .</p>
<p>If two methods produce the same item name (for example,</p><div class="fragment"><div class="line">getOwner </div></div><!-- fragment --><p> and</p><div class="fragment"><div class="line">isOwner </div></div><!-- fragment --><p> , or</p><div class="fragment"><div class="line">getOwner </div></div><!-- fragment --><p> and</p><div class="fragment"><div class="line">getowner </div></div><!-- fragment --><p> ) then the type is not convertible.</p>
<p>When the Open Type is</p><div class="fragment"><div class="line">CompositeType </div></div><!-- fragment --><p> , the corresponding mapped Java type (<em>opendata(J)</em>) is <a class="el" href="">CompositeData</a>. The mapping from an instance of <em>J</em> to a </p><div class="fragment"><div class="line">CompositeData </div></div><!-- fragment --><p> corresponding to the</p><div class="fragment"><div class="line">CompositeType </div></div><!-- fragment --><p> just described is done as follows. First, if <em>J</em> implements the interface <a class="el" href="">CompositeDataView</a>, then that interface's <a class="el" href="interfacejavax_1_1management_1_1openmbean_1_1_composite_data_view.html#ae20f222033167af83754d0a36e549dd2">toCompositeData</a> method is called to do the conversion. Otherwise, the</p><div class="fragment"><div class="line">CompositeData </div></div><!-- fragment --><p> is constructed by calling the getter for each item and converting it to the corresponding Open Data type. Thus, a getter such as</p>
<blockquote class="doxtable">
<div class="fragment"><div class="line">List&lt;String&gt; getNames() </div></div><!-- fragment --> </blockquote>
<p>will have been mapped to an item with name "@code names @endcode " and Open Type</p><div class="fragment"><div class="line">ArrayType(1, SimpleType.STRING) </div></div><!-- fragment --><p> . The conversion to</p><div class="fragment"><div class="line">CompositeData </div></div><!-- fragment --><p> will call</p><div class="fragment"><div class="line">getNames() </div></div><!-- fragment --><p> and convert the resultant</p><div class="fragment"><div class="line">List&lt;String&gt; </div></div><!-- fragment --><p> into a</p><div class="fragment"><div class="line">String[] </div></div><!-- fragment --><p> for the item "@code names @endcode ".</p>
<div class="fragment"><div class="line">CompositeData </div></div><!-- fragment --><p> is an interface. The concrete class that is used to represent a type as Open Data is <a class="el" href="">CompositeDataSupport</a>, or another class implementing</p><div class="fragment"><div class="line">CompositeData </div></div><!-- fragment --><p> that serializes as</p><div class="fragment"><div class="line">CompositeDataSupport </div></div><!-- fragment --><p> .</p>
<pre class="fragment">&lt;h4&gt;Reconstructing an instance of Java type &lt;em&gt;J&lt;/em&gt; from
  a@code CompositeData @endcode &lt;/h4&gt;

&lt;p&gt;If &lt;em&gt;opendata(J)&lt;/em&gt; is@code CompositeData @endcode  for a Java type
  &lt;em&gt;J&lt;/em&gt;, then either an instance of &lt;em&gt;J&lt;/em&gt; can be
  reconstructed from a@code CompositeData @endcode , or &lt;em&gt;J&lt;/em&gt; is not
  reconstructible.  If any item in the@code CompositeData @endcode  is not
  reconstructible, then &lt;em&gt;J&lt;/em&gt; is not reconstructible either.&lt;/p&gt;

&lt;p&gt;For any given &lt;em&gt;J&lt;/em&gt;, the following rules are consulted to
  determine how to reconstruct instances of &lt;em&gt;J&lt;/em&gt; from
</pre> <div class="fragment"><div class="line">CompositeData </div></div><!-- fragment --><p> . The first applicable rule in the list is the one that will be used.</p>
<ol>
<li>
<p class="startli"></p>
<p>If <em>J</em> has a method<br />
 </p><div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keyword">static</span>  </div></div><!-- fragment --><p> <em>J </em></p><div class="fragment"><div class="line">from(CompositeData cd) </div></div><!-- fragment --><p> <br />
 then that method is called to reconstruct an instance of <em>J</em>.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p>Otherwise, if <em>J</em> has at least one public constructor with a <a class="el" href="interfacejava_1_1beans_1_1_constructor_properties.html">ConstructorProperties</a> annotation, then one of those constructors (not necessarily always the same one) will be called to reconstruct an instance of <em>J</em>. Every such annotation must list as many strings as the constructor has parameters; each string must name a property corresponding to a getter of <em>J</em>; and the type of this getter must be the same as the corresponding constructor parameter. It is not an error for there to be getters that are not mentioned in the</p><div class="fragment"><div class="line">ConstructorProperties </div></div><!-- fragment --><p> annotation (these may correspond to information that is not needed to reconstruct the object).</p>
<p></p>
<p></p>
<p>An instance of <em>J</em> is reconstructed by calling a constructor with the appropriate reconstructed items from the </p><div class="fragment"><div class="line">CompositeData </div></div><!-- fragment --><p> . The constructor to be called will be determined at runtime based on the items actually present in the</p><div class="fragment"><div class="line">CompositeData </div></div><!-- fragment --><p> , given that this</p><div class="fragment"><div class="line">CompositeData </div></div><!-- fragment --><p> might come from an earlier version of <em>J</em> where not all the items were present. A constructor is <em>applicable</em> if all the properties named in its</p><div class="fragment"><div class="line">ConstructorProperties </div></div><!-- fragment --><p> annotation are present as items in the</p><div class="fragment"><div class="line">CompositeData </div></div><!-- fragment --><p> . If no constructor is applicable, then the attempt to reconstruct <em>J</em> fails.</p>
<p></p>
<p></p>
<p>For any possible combination of properties, it must be the case that either (a) there are no applicable constructors, or (b) there is exactly one applicable constructor, or (c) one of the applicable constructors names a proper superset of the properties named by each other applicable constructor. (In other words, there should never be ambiguity over which constructor to choose.) If this condition is not true, then <em>J</em> is not reconstructible.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p>Otherwise, if <em>J</em> has a public no-arg constructor, and for every getter in <em>J</em> with type <em>T</em> and name <em>N</em> there is a corresponding setter with the same name and type, then an instance of <em>J</em> is constructed with the no-arg constructor and the setters are called with the reconstructed items from the</p><div class="fragment"><div class="line">CompositeData </div></div><!-- fragment --><p> to restore the values. For example, if there is a method<br />
 </p><div class="fragment"><div class="line"><span class="keyword">public</span> List&lt;String&gt; getNames() </div></div><!-- fragment --><p> <br />
 then there must also be a method<br />
 </p><div class="fragment"><div class="line"><span class="keyword">public</span> <span class="keywordtype">void</span> setNames(List&lt;String&gt; names) </div></div><!-- fragment --><p> <br />
 for this rule to apply.</p>
<p></p>
<p></p>
<p>If the</p><div class="fragment"><div class="line">CompositeData </div></div><!-- fragment --><p> came from an earlier version of <em>J</em>, some items might not be present. In this case, the corresponding setters will not be called.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p>Otherwise, if <em>J</em> is an interface that has no methods other than getters, an instance of <em>J</em> is constructed using a <a class="el" href="classjava_1_1lang_1_1reflect_1_1_proxy.html">java.lang.reflect.Proxy</a> with a <a class="el" href="">CompositeDataInvocationHandler</a> backed by the</p><div class="fragment"><div class="line">CompositeData </div></div><!-- fragment --><p> being converted.</p>
<p></p>
<p class="endli"></p>
</li>
<li>
<p class="startli"></p>
<p>Otherwise, <em>J</em> is not reconstructible.</p>
<p class="endli"></p>
</li>
</ol>
<p>Rule 2 is not applicable to subset Profiles of Java SE that do not include the</p><div class="fragment"><div class="line"><a class="code" href="namespacejava.html">java</a>.<a class="code" href="namespacejava_1_1beans.html">beans</a> </div></div><!-- fragment --><p> package. When targeting a runtime that does not include the</p><div class="fragment"><div class="line"><a class="code" href="namespacejava.html">java</a>.<a class="code" href="namespacejava_1_1beans.html">beans</a> </div></div><!-- fragment --><p> package, and where there is a mismatch between the compile-time and runtime environment whereby <em>J</em> is compiled with a public constructor and the</p><div class="fragment"><div class="line">ConstructorProperties </div></div><!-- fragment --><p> annotation, then <em>J</em> is not reconstructible unless another rule applies.</p>
<p>Here are examples showing different ways to code a type</p><div class="fragment"><div class="line">NamedNumber </div></div><!-- fragment --><p> that consists of an</p><div class="fragment"><div class="line"><span class="keywordtype">int</span> </div></div><!-- fragment --><p> and a</p><div class="fragment"><div class="line">String </div></div><!-- fragment --><p> . In each case, the</p><div class="fragment"><div class="line">CompositeType </div></div><!-- fragment --><p> looks like this:</p>
<blockquote class="doxtable">
<pre>
<a class="el" href="">CompositeType</a>(
    "NamedNumber",                      // typeName
    "NamedNumber",                      // description
    new String[] {"number", "name"},    // itemNames
    new String[] {"number", "name"},    // itemDescriptions
    new OpenType[] {<a class="el" href="classjavax_1_1management_1_1openmbean_1_1_simple_type.html#a19dbfb72f33e2a99d65e51a2161a342d">SimpleType.INTEGER</a>,
                    <a class="el" href="classjavax_1_1management_1_1openmbean_1_1_simple_type.html#a85efef9090948a4a9da6474ba01ccf93">SimpleType.STRING</a>}  // itemTypes
);
      </pre> </blockquote>
<ol>
<li>
<p class="startli">Static</p><div class="fragment"><div class="line">from </div></div><!-- fragment --><p> method:</p>
<blockquote class="doxtable">
<pre>
public class NamedNumber {
    public int getNumber() {return number;}
    public String getName() {return name;}
    private NamedNumber(int number, String name) {
        this.number = number;
        this.name = name;
    }
    <b>public static NamedNumber from(CompositeData cd)</b> {
        return new NamedNumber((Integer) cd.get("number"),
                               (String) cd.get("name"));
    }
    private final int number;
    private final String name;
}
          </pre> </blockquote>
<p class="endli"></p>
</li>
<li>
<p class="startli">Public constructor with <code>&amp;#64;ConstructorProperties</code> annotation:</p>
<blockquote class="doxtable">
<pre>
public class NamedNumber {
    public int getNumber() {return number;}
    public String getName() {return name;}
    <b>&amp;#64;ConstructorProperties({"number", "name"})
    public NamedNumber(int number, String name)</b> {
        this.number = number;
        this.name = name;
    }
    private final int number;
    private final String name;
}
          </pre> </blockquote>
<p class="endli"></p>
</li>
<li>
<p class="startli">Setter for every getter:</p>
<blockquote class="doxtable">
<pre>
public class NamedNumber {
    public int getNumber() {return number;}
    public void <b>setNumber</b>(int number) {this.number = number;}
    public String getName() {return name;}
    public void <b>setName</b>(String name) {this.name = name;}
    <b>public NamedNumber()</b> {}
    private int number;
    private String name;
}
          </pre> </blockquote>
<p class="endli"></p>
</li>
<li>
<p class="startli">Interface with only getters:</p>
<blockquote class="doxtable">
<pre>
public interface NamedNumber {
    public int getNumber();
    public String getName();
}
          </pre> </blockquote>
</li>
</ol>
<p>It is usually better for classes that simply represent a collection of data to be <em>immutable</em>. An instance of an immutable class cannot be changed after it has been constructed. Notice that</p><div class="fragment"><div class="line">CompositeData </div></div><!-- fragment --><p> itself is immutable. Immutability has many advantages, notably with regard to thread-safety and security. So the approach using setters should generally be avoided if possible.</p>
<pre class="fragment">&lt;h3&gt;Recursive types&lt;/h3&gt;

&lt;p&gt;Recursive (self-referential) types cannot be used in MXBean
  interfaces.  This is a consequence of the immutability of {@link
  CompositeType}.  For example, the following type could not be the
  type of an attribute, because it refers to itself:&lt;/p&gt;

&lt;pre&gt;
</pre><p> public interface <b>Node</b> { public String getName(); public int getPriority(); public <b>Node</b> getNext(); }  </p><pre class="fragment">&lt;p&gt;It is always possible to rewrite recursive types like this so
  they are no longer recursive.  Doing so may require introducing
  new types.  For example:&lt;/p&gt;

&lt;pre&gt;
</pre><p> public interface <b>NodeList</b> { public List&lt;Node&gt; getNodes(); }</p>
<p>public interface Node { public String getName(); public int getPriority(); }  </p><pre class="fragment">&lt;h3&gt;MBeanInfo contents for an MXBean&lt;/h3&gt;

&lt;p&gt;An MXBean is a type of Open MBean.  However, for compatibility
  reasons, its {@link MBeanInfo} is not an {@link OpenMBeanInfo}.
  In particular, when the type of an attribute, parameter, or
  operation return value is a primitive type such as@code int @endcode ,
  or is@code void @endcode  (for a return type), then the attribute,
  parameter, or operation will be represented respectively by an
  {@link MBeanAttributeInfo}, {@link MBeanParameterInfo}, or
  {@link MBeanOperationInfo} whose@code getType() @endcode  or@code 
  getReturnType() @endcode  returns the primitive name ("@code int @endcode " etc).
  This is so even though the mapping rules above specify that the
  &lt;em&gt;opendata&lt;/em&gt; mapping is the wrapped type (@code Integer @endcode 
  etc).&lt;/p&gt;

&lt;p&gt;The array of public constructors returned by {@link
  MBeanInfo#getConstructors()} for an MXBean that is directly
  registered in the MBean Server will contain all of the public
  constructors of that MXBean.  If the class of the MXBean is not
  public then its constructors are not considered public either.
  The list returned for an MXBean that is constructed using the
  {@link StandardMBean} class is derived in the same way as for
  Standard MBeans.  Regardless of how the MXBean was constructed,
  its constructor parameters are not subject to MXBean mapping
  rules and do not have a corresponding@code OpenType @endcode .&lt;/p&gt;

&lt;p&gt;The array of notification types returned by {@link
  MBeanInfo#getNotifications()} for an MXBean that is directly
  registered in the MBean Server will be empty if the MXBean does
  not implement the {@link NotificationBroadcaster} interface.
  Otherwise, it will be the result of calling {@link
  NotificationBroadcaster#getNotificationInfo()} at the time the MXBean
  was registered.  Even if the result of this method changes
  subsequently, the result of@code MBeanInfo.getNotifications() @endcode 
  will not.  The list returned for an MXBean that is constructed
  using the {@link StandardMBean} or {@link StandardEmitterMBean}
  class is derived in the same way as for Standard MBeans.&lt;/p&gt;

&lt;p&gt;The {@link Descriptor} for all of the
</pre> <div class="fragment"><div class="line">MBeanAttributeInfo </div></div><!-- fragment --><p> ,</p><div class="fragment"><div class="line">MBeanParameterInfo </div></div><!-- fragment --><p> , and </p><div class="fragment"><div class="line">MBeanOperationInfo </div></div><!-- fragment --><p> objects contained in the</p><div class="fragment"><div class="line">MBeanInfo </div></div><!-- fragment --><p> will have a field</p><div class="fragment"><div class="line">openType </div></div><!-- fragment --><p> whose value is the <a class="el" href="">OpenType</a> specified by the mapping rules above. So even when</p><div class="fragment"><div class="line">getType() </div></div><!-- fragment --><p> is "@code int @endcode ",</p><div class="fragment"><div class="line">getDescriptor().getField(<span class="stringliteral">&quot;openType&quot;</span>) </div></div><!-- fragment --><p> will be <a class="el" href="classjavax_1_1management_1_1openmbean_1_1_simple_type.html#a19dbfb72f33e2a99d65e51a2161a342d">SimpleType#INTEGER</a>.</p>
<p>The</p><div class="fragment"><div class="line">Descriptor </div></div><!-- fragment --><p> for each of these objects will also have a field</p><div class="fragment"><div class="line">originalType </div></div><!-- fragment --><p> that is a string representing the Java type that appeared in the <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> interface. The format of this string is described in the section <a href="#type-names">Type Names</a> below.</p>
<p>The</p><div class="fragment"><div class="line">Descriptor </div></div><!-- fragment --><p> for the</p><div class="fragment"><div class="line">MBeanInfo </div></div><!-- fragment --><p> will have a field </p><div class="fragment"><div class="line">mxbean </div></div><!-- fragment --><p> whose value is the string "@code true @endcode ".</p>
<pre class="fragment">&lt;h3 id="type-names"&gt;Type Names&lt;/h3&gt;

&lt;p&gt;Sometimes the unmapped type &lt;em&gt;T&lt;/em&gt; of a method parameter or
return value in an MXBean must be represented as a string.  If
&lt;em&gt;T&lt;/em&gt; is a non-generic type, this string is the value
returned by {@link Class#getName()}.  Otherwise it is the value of
&lt;em&gt;genericstring(T)&lt;/em&gt;, defined as follows:

&lt;ul&gt;

  &lt;li&gt;If &lt;em&gt;T&lt;/em&gt; is a non-generic non-array type,
  &lt;em&gt;genericstring(T)&lt;/em&gt; is the value returned by {@link
  Class#getName()}, for example@code "int" @endcode  or@code 
  "java.lang.String" @endcode .

  &lt;li&gt;If &lt;em&gt;T&lt;/em&gt; is an array &lt;em&gt;E[]&lt;/em&gt;,
  &lt;em&gt;genericstring(T)&lt;/em&gt; is &lt;em&gt;genericstring(E)&lt;/em&gt; followed
  by@code "[]" @endcode .  For example, &lt;em&gt;genericstring(@code int[] @endcode )&lt;/em&gt;
  is@code "int[]" @endcode , and &lt;em&gt;genericstring(@code 
  List&lt;String&gt;[][] @endcode )&lt;/em&gt; is@code 
  "java.util.List&lt;java.lang.String&gt;[][]" @endcode .

&lt;li&gt;Otherwise, &lt;em&gt;T&lt;/em&gt; is a parameterized type such as@code 
List&lt;String&gt; @endcode  and &lt;em&gt;genericstring(T)&lt;/em&gt; consists of the
following: the fully-qualified name of the parameterized type as
returned by@code Class.getName() @endcode ; a left angle bracket (@code 
"&lt;" @endcode ); &lt;em&gt;genericstring(A)&lt;/em&gt; where &lt;em&gt;A&lt;/em&gt; is the first
type parameter; if there is a second type parameter &lt;em&gt;B&lt;/em&gt;
then@code ", " @endcode  (a comma and a single space) followed by
&lt;em&gt;genericstring(B)&lt;/em&gt;; a right angle bracket (@code "&gt;" @endcode ).

&lt;/ul&gt;

&lt;p&gt;Note that if a method returns@code int[] @endcode , this will be
  represented by the string@code "[I" @endcode  returned by@code 
  Class.getName() @endcode , but if a method returns@code List&lt;int[]&gt; @endcode ,
  this will be represented by the string@code 
  "java.util.List&lt;int[]&gt;" @endcode .

&lt;h3&gt;Exceptions&lt;/h3&gt;

&lt;p&gt;A problem with mapping &lt;em&gt;from&lt;/em&gt; Java types &lt;em&gt;to&lt;/em&gt;
  Open types is signaled with an {@link OpenDataException}.  This
  can happen when an MXBean interface is being analyzed, for
  example if it references a type like {@link java.util.Random
  java.util.Random} that has no getters.  Or it can happen when an
  instance is being converted (a return value from a method in an
  MXBean or a parameter to a method in an MXBean proxy), for
  example when converting from@code SortedSet&lt;String&gt; @endcode  to@code 
  String[] @endcode  if the@code SortedSet @endcode  has a non-null@code 
  Comparator @endcode .&lt;/p&gt;

&lt;p&gt;A problem with mapping &lt;em&gt;to&lt;/em&gt; Java types &lt;em&gt;from&lt;/em&gt;
  Open types is signaled with an {@link InvalidObjectException}.
  This can happen when an MXBean interface is being analyzed, for
  example if it references a type that is not
  &lt;em&gt;reconstructible&lt;/em&gt; according to the rules above, in a
  context where a reconstructible type is required.  Or it can
  happen when an instance is being converted (a parameter to a
  method in an MXBean or a return value from a method in an MXBean
  proxy), for example from a String to an Enum if there is no Enum
  constant with that name.&lt;/p&gt;

&lt;p&gt;Depending on the context, the@code OpenDataException @endcode  or
</pre> <div class="fragment"><div class="line">InvalidObjectException </div></div><!-- fragment --><p> may be wrapped in another exception such as <a class="el" href="classjavax_1_1management_1_1_runtime_m_bean_exception.html">RuntimeMBeanException</a> or <a class="el" href="">UndeclaredThrowableException</a>. For every thrown exception, the condition <em>C</em> will be true: "<em>e</em> is</p><div class="fragment"><div class="line">OpenDataException </div></div><!-- fragment --><p> or</p><div class="fragment"><div class="line">InvalidObjectException </div></div><!-- fragment --><p> (as appropriate), or <em>C</em> is true of <em>e</em>.<a class="el" href="">getCause()</a>".</p>
<dl class="section since"><dt>Since</dt><dd>1.6 </dd></dl>

<p>Definition at line <a class="el" href="_m_x_bean_8java_source.html#l01182">1182</a> of file <a class="el" href="_m_x_bean_8java_source.html">MXBean.java</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0b77e799efe09dbb3a5d8aefc160d139"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean javax.management.MXBean.value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>True if the annotated interface is an <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> interface. </p><dl class="section return"><dt>Returns</dt><dd>true if the annotated interface is an <a class="el" href="interfacejavax_1_1management_1_1_m_x_bean.html">MXBean</a> interface. </dd></dl>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="interfacejavax_1_1management_1_1_m_x_bean_a0b77e799efe09dbb3a5d8aefc160d139_icgraph.png" border="0" usemap="#interfacejavax_1_1management_1_1_m_x_bean_a0b77e799efe09dbb3a5d8aefc160d139_icgraph" alt=""/></div>
<map name="interfacejavax_1_1management_1_1_m_x_bean_a0b77e799efe09dbb3a5d8aefc160d139_icgraph" id="interfacejavax_1_1management_1_1_m_x_bean_a0b77e799efe09dbb3a5d8aefc160d139_icgraph">
<area shape="rect" id="node2" href="classjavax_1_1management_1_1_j_m_x.html#aef68d46e5093a2fc3dce59d5efaa3372" title="javax.management.JMX.isMXBean\lInterface" alt="" coords="268,5,488,47"/>
</map>
</div>
</p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li>E:/00_Code/openjdk8/javax/management/<a class="el" href="_m_x_bean_8java_source.html">MXBean.java</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
